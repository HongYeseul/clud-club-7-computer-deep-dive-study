## 2.5. 콜백함수를 철저하게 이해한다.

### 2.5.1. 모든 것은 다음 요구에서 시작된다

서비스를 개발할 때, B팀에서 핵심 모듈(함수) 개발, A, C, D, E, F, … 수많은 팀에서 이를 호출하여 사용. 함수 내 개별 팀에게 필요한 커스텀 로직을 조건문으로 분리하는건 잘못된 설계로 판단함.

### 2.5.2. 콜백이 필요한 이유

사실은 함수를 변수처럼 사용할 수도 있습니다. (매개변수로 함수를 변수처럼 넘긴다는 의미)
⇒ “함수 변수”라는 이름은 난해하므로 ‘이해 불가능’의 원칙에 따라 이를 콜백함수로 부르자!

### 2.5.3.-2.5.4. 비동기 콜백~비동기 콜백은 새로운 프로그래밍 사고방식으로 이어진다

- 비동기콜백: 호출 스레드가 콜백 함수 실행에 의존하지 않는 것
- 동기 호출(synchronous call): 함수를 호출 할 때, 프로그래머에게 가장 익숙한 사고방식
  - 함수를 호출하고 결과를 획득한다
  - 획득한 결과를 처리한다.
- 비동기 호출(asynchronous call): 작업 처리가 두 부분으로 나뉨(스레드 2개 이용)

🌟 콜백 함수의 본질

“우리는 어떤 일을 해야 하는지 알지만, 이 일을 언제 하게 될지는 정확히 알 수 없습니다. 반면에 다른 모듈은 언제 해야 할지는 알지만 무엇을 해야 하는지는 모르기 때문에 우리가 알고 있는 정보를 콜백 함수에 잘 담아 다른 모듈에 전달해야 합니다. “

### 2.5.5. 콜백 함수의 정의

: 다른 코드에 매개변수로 전달되는 실행 가능한 코드 > 콜백함수와 호출자는 서로 다른 계층에 존재한다. ( 내가 전달한 콜백함수를 다른 서드 파티 라이브러리가 콜백함수를 호출한다는 의미에서)

- 콜백함수가 호출되는 시점
  - 일반적으로 시스템에서 / 네트워크 데이터 수신이나 파일 전송 완료처럼 관심 대상인 이벤트가 발생하면 / 이를 처리할 수 있는 코드를 호출하고 싶어할 것이다. ⇒ 이때 유용
  - 이벤트가 발생하면 상응하는 콜백함수가 자동으로 호출되며, 이 관점에서 **콜백함수는 이벤트 처리 도구**이기에 **이벤트 중심 프로그래밍에 적합**하다.

### 2.5.6. 두가지 콜백 유형

- 동기 콜백(=블로킹 콜백)
- 비동기 콜백(=지연 콜백)

### 2.5.7. 비동기 콜백의 문제: 콜백 지옥

서버에서 작업을 처리할 때 사용자에게 전달되는 데이터 서비스는 하나씩 호출되는 것이 아니라, 수십개 또는 수백개씩 호출될 때가 대부분 ⇒ 비즈니스 구성이 복잡할때 비동기 콜백으로 처리하면 콜백 지옥에 빠지게

---

## 2.6. 동기와 비동기를 철저하게 이해한다

### 2.6.3. 동기 호출

funcA함수가 funcB함수를 내부에서 호출하면, funcB함수가 완료될 때까지 나머지 코드는 실행되지 않음. funcA함수와 funcB함수가 동일한 스레드에서 실행되는 익숙한 상황.

### 2.6.4. 비동기 호출

동기작업에선 해당 함수가 반환될 때 해당 작업이 모두 완료되었음을 의미하지만, 비동기 호출에선 파일 읽기 작업이 언제 완료되었는지 어떻게 알 수 있을까? 또 어떻게 그 결과를 처리해야 할까?

1. 호출자가 실행 결과를 전혀 신경 쓰지 않는 상황
   1. 콜백함수를 이용 > ‘계속해서 파일을 읽고, 작업이 완료되면 전달된 함수를 사용하여 파일을 처리해주세요’ > 호출자 스레드가 아닌 콜백 함수가 실행되는 다른 스레드/프로세스 등에서 처리
2. 호출자가 실행 결과를 반드시 알아야 하는 상황
   1. 알림 작동 방식 이용 > 작업 실행이 완료되면 호출자에게 작업 완료를 알리는 신호나 메세지를 보냄 > 결과 처리는 이전과 마찬가지로 호출 스레드에서 진행함

---

## 2.7. 아 맞다! 블로킹과 논블로킹도 있다

### 2.7.2. 블로킹의 핵심 문제: 입출력

프로그램, 스레드, 프로세스가 입출력 작업을 할 때, 우리 스레드에선 CPU제어권을 다른 스레드에 넘겨 다른 작업을 할 수 있도록 해야 함. 완료되면 다시 CPU제어권을 우리 스레드로 넘겨받아 다음 작업 실행할 수 있도록 해야 함.

결론: 입출력 작업 너무 느림 > 가끔 호출 스레드가 블로킹되어 일시 중지됨 > 호출 스레드가 일시중지 되지 않는 방법 없을까 > 논블로킹 호출

### 2.7.3.~ 논블로킹과 비동기 입출력 / 비동기와 논블로킹

입출력 함수 호출 시,

- 결과 획득을 위해 기다리겠다(동기)
  - caller 스레드를 **일시정지** 시키고, CPU의 제어권을 다른 스레드에 넘겨 CPU 유휴시간을 줄임. **즉, CPU 제어권을 상실했다가 되찾는 시간 동안 스레드/프로세스는 블로킹 되는 것.**
  - 운영체제 입장에서 **동기 입출력 호출**에는 무조건 **블로킹**으로 대응하는 것이 효율적.
  - 동기 호출이 무조건 블로킹은 아니지만, **블로킹이면 반드시 동기 호출이라고 할 수 있다.**
- 결과 획득을 위해 기다리지 않겠다(비동기)
  - callee 는 즉시 반환하고 caller 스레드는 **CPU 제어권을 유지**한 채 기존 작업을 계속 진행함.
    이 때 입출력 과정이 다른 스레드(주로 커널)에서 병행됨으로 효율적.
  - 결과 처리를 세 가지 방법
    - 입출력 함수와 같이 제공되는, '결과를 확인하는 함수'를 통해 데이터가 들어왔는지를 확인하고 caller 스레드가 처리함.
    - 데이터가 들어왔는지를 알림 작동방식을 통해 caller 스레드에 전달. 전달 받은 caller 스레드가 처리.
    - 입출력 함수 호출 시 콜백 함수를 넘김. callee 스레드가 처리.

단, CPU 제어권을 유지(논블로킹) 했다고 해도, 데이터 획득을 위해 **caller 스레드가 기다리고 있다면**,

이는 논블로킹이더라도 동기 호출임. 즉, 논블로킹이라고 모두 비동기 호출은 아님.

---

## 2.8. 높은 동시성과 고성능을 갖춘 서버 구현

### 2.8.1. 다중 프로세스

자식 프로세스를 이용한 사용자 요청 처리(리눅스에서 fork)

- (+)프로그래밍 간단하여 이해하기 쉬움
- (+)개발 프로세스의 주소공간 격리되어 있어, 문제 생겨도 타 프로세스 영향 없음
- (+)다중 코어 리소스 활용 가능
- (-)프로세스 간 통신 비용/난이도/생성,종료 비싸고 어려움

### 2.8.3. 다중 스레드

스레드는 프로세스의 주소 공간을 공유하기 때문에 별도의 통신 작동 방식 필요 없음

- (+) 각 요청에 대응하는 스레드 생성하여, 스레드 일부가 블로킹되어도 타 스레드에 영향 없음
- (-) 같은 주소 공간 공유하기에 한번에 강제 종료 가능 > 여ㅓ 스레드가 동시에 공유 리소스의 데이터를 읽고 쓸수 있다는 부작용

### 2.8.3. 이벤트 순환과 이벤트 구동

이벤트 기반의 동시성을 이용한 이벤트 기반 프로그래밍

- 이벤트: 대부분 입출력 관계(네트워크 데이터의 수신 여부, 파일의 읽기 및 쓰기 가능 여부 등)
- 이벤트를 처리하는 함수(이벤트 핸들러)

### 2.8.4. 첫번째 문제: 이벤트 소스와 입출력 다중화

1. 이벤트 소스: `getEvent()` 하나로 어떻게 여러 이벤트를 가져올 수 있는가.
   - **입출력 다중화 (I/O multiplexing)**
     - 모든 입출력은 'file'. 모든 입출력 작업은 file descriptor를 통해. 소켓도 마찬가지.
     - 다수의 소켓에 대해서, file descriptor 를 순차적으로 듣거나, 여러 프로세스/스레드가 하나씩 듣고 있는 것은 비효율적.
     - 여러 개의 소켓 즉 file descriptor 를 대신 듣고 있다가 데이터가 수신되면 반환하는 방식이 **입출력 다중화**.
     - 이벤트 루프의 '엔진' 역할을 하는 것.
     - 리눅스 세계에서는 `epoll` 이 대표적.
2. 이벤트 처리: `handler` 함수가 꼭 같은 스레드에서 실행되어야 하는가.
   - **리액터 패턴 (reactor pattern)**
     - 만약 handler 함수의 동작이 입출력이 없는 매우 짧은 작업이라면, 이벤트 루프와 동일한 스레드에서 실행해도 무방함.
     - 하지만 handler 함수의 동작에 시간이 많이 든다면, 반응성을 위해 다중 스레드를 활용.
     - 이벤트 루프가 실행되는 스레드 하나와 여러 개의 작업자 스레드를 두어서,**이벤트 수신 시 이벤트 루프 스레드에서 간단한 처리 후 작업자 스레드에 처리 작업을 분배**.
     - 스레드 풀 형태로 구현할 수 있음
     - 이런 설계 방법을 리액터 패턴 (reactor pattern)이라고 함.
     - 만약 처리 과정에 블로킹 입출력이 있다면 **반드시** 해당 작업은 작업자 스레드에 전달해야함.

입출력 다중화와 리액터 패턴을 활용한 프레임워크를 확정하고 나면,

프로그래머는 이벤트 처리 함수 (handler) 구현에 집중하면 됨.

### 2.8.9. 코루틴: 동기방식의 비동기 프로그래밍

- 코루틴(Coroutine)은 함수의 실행을 **중간에 멈췄다가 다시 이어서** 실행할 수 있는 함수
- 핵심 포인트:
  - **함수를 멈추고 상태를 기억한 채 나중에 재개**할 수 있다.
  - **비동기 작업**을 동기 코드처럼 **순차적으로 작성**할 수 있다.
  - **멀티스레드 없이 동시성 처리**가 가능하다.
- **"스레드의 CPU 시간을 2차 할당한다"**
  - **기존 스레드 방식**에서는:
  - 운영체제(OS)가 **"스레드"** 단위로 **CPU 시간을 할당함.**
  - 즉, **OS가 직접 "너 지금 CPU 써! 너는 잠깐 기다려!"** 이런 식으로 스케줄링
- **코루틴 방식**에서는:
  - 하나의 스레드(기존 할당된 CPU 시간) 안에서, **코루틴이 또다시 CPU 시간을 나눠 씀** → "2차 할당"
  - 즉, **운영체제가 아니라 사용자 코드가 직접 코루틴 간 스케줄링을 관리**
  - 결과적으로 **한 스레드에서 여러 작업이 돌아가는 효과**
- 결론: "코루틴은 운영체제가 할당한 스레드의 CPU 시간을 사용자 상태에서 다시 여러 작업에 나눠 쓰는 방식이다.”

---

1. **I/O 요청 발생**→ (네트워크, 파일, DB 같은 느린 작업)
2. **epoll**→ OS가 I/O 상태를 감시 (리눅스의 고성능 비동기 I/O 시스템)
3. **이벤트 루프 (Event Loop)**→ I/O 작업이 끝났는지 계속 확인
4. **코루틴 생성**→ 작업을 수행할 코루틴 준비
5. **준비된 코루틴 대기열 관리**→ 동시에 실행할 수 있는 코루틴들을 관리
6. **코루틴 실행**→ 실제로 CPU 시간을 써서 작업 진행
7. **스레드 여러 개 (CPU)**→ CPU가 필요한 작업은 여러 스레드로 분산 (멀티코어 활용)
