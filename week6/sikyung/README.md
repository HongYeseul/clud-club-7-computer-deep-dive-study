## 3.5. 메모리를 할당할 때 저수준 계층에서 일어나는 일

### 프로그램 종류별로 존재하는 등급

- x86 CPU는 '네 가지 특권 단계(privilege level)'를 제공함. 일부 명령어를 실행할 수 있는지 나타내며, 0단계일때 특권이 가장 큼. ( 특권 O단계를 흔히 RING 0에 속한다고 표현함)
- 일반적인 시스템이 사용하는 CPU 단계
  - 0단계: 커널 모드: 운영체제(OS)가 CPU를 사용하는 모드이다. 시스템 콜을 통해 커널모드로 전환이 되면 운영체제는 하드웨어를 제어하는 명령어(Privileged Instructions)를 실행한다. Privileged Instructions는 사용자 모드에서 실행되면 exception이 발생한다.
  - 3단계: 사용자 모드: 사용자 모드에서 사용자 애플리케이션 코드가 실행된다. 사용자가 접근할 수 있는 영역에 제한이 있기 때문에 해당 모드에서는 하드웨어(디스크, I/O 등)에 접근할 수 없다.

### 시스템 콜

- 사용자 상태에서 시작되어 커널 상태에서 처리되는 시스템 호출. CPU는 커널 상태에서는 응용 프로그램을 실행할 수 없는 반면, 사용자 상태에서는 운영체제의 코드를 실행 불가능 함. -> 시스템 콜 이용

- 사용자 상태에서 시작되어 커널 상태에서 처리되는 시스템 호출
  <img width="352" alt="Image" src="https://github.com/user-attachments/assets/df315f02-41f9-4ccc-bf8b-b8fd26fe96d8" />

- [시스템 콜 종류](https://didu-story.tistory.com/311)

- 표준 라이브러리: 시스템 호출로 운영체제와 소통하며, 운영체제는 저수준 하드웨어를 관리한다.
  <img width="641" alt="Image" src="https://github.com/user-attachments/assets/260db607-0b91-4bae-9156-36da30cb386d" />

### 힙 영역의 메모리가 부족할 때

- malloc()같은 메모리 할당자는 표준 라이브러리의 일부로 구현되어 있음.
- 프로세스 주소 공간중 힙 영역과 스택 영역 사이엔 여유 공간이 있음. 힙 영역이 늘어나면 점유하는 메모리가 많아지므로 여유 메모리 조각이 부족한 문제 발생

  - brk: 리눅스의 모든 프로세스에는 brk(브레이크:break)변수가 존재함, 힙 영역의 최상단을 가리킴. brk 전용 시스템 호출을 이용하여 조절하는 방식으로 힙영역의 크기 조절
  - mmap: mmap가 힙 메모리 부족과 관련되는 이유
    기존 malloc()은 내부적으로 brk() 시스템 콜을 이용해서 힙 영역을 확장함. 하지만 brk 방식은 힙과 스택 사이 여유 공간을 활용하는 구조라서, 여유 공간이 부족해지면 → mmap 방식으로 전환됨. <br />
    그래서, 메모리 조각화 방지 / 힙-스택 경계와 무관하게 메모리 할당 가능 / 대용량 메모리 할당 시 더 안정적 / glibc 기준으로 malloc()은 작은 요청은 brk, 큰 요청은 mmap 사용함

- brk와 mmap
  | 구분 | brk | mmap |
  |------------|------------------------------------------|------------------------------------------------|
  | 확장 방식 | 힙 영역 끝 위치(brk 포인터) 조절 | 별도의 주소 공간에 메모리 매핑 |
  | 주소 영역 | 힙 영역 내부 | 힙 외부 영역 (커널이 임의의 공간 매핑) |
  | 장점 | 구현이 간단, 작은 요청에 적합 | 대용량 요청 처리에 효율적, 메모리 조각화 방지 |
  | 단점 | 메모리 조각화 발생 가능 | 시스템 자원 사용 증가, 해제 시 처리 필요 |
  | 사용 시점 | 작은 크기의 `malloc()` 요청 시 사용 | 큰 크기의 `malloc()` 요청 시 내부적으로 사용 |
  | 예시 | `sbrk()`, `brk()` | `mmap()`, `munmap()` |

<hr />

## 3.6. 고성능 서버의 메모리 풀은 어떻게 구현될까?

- 메모리 풀 기술의 원리: (malloc()을 너무 자주 호출하면 성능이 떨어지니까)한번에 큰 메모리 조각을 요청하고 그위에서 자체적으로 메모리 할당과 해제를 관리하는 방식으로 표준 라이브러리와 운영체제를 우회함
  <img width="351" alt="Image" src="https://github.com/user-attachments/assets/1adb0439-be47-4b2b-978f-973763b85618" />

- 연결리스트로 메모리 조각 관리

  - Free_ptr는 아직 사용되지 않은 "유휴 메모리"를 가리키고 있음.
  - 앞의 “이미 할당”된 덩어리들은 malloc()을 통해 이미 사용된 영역이고, 각 조각은 연결 리스트 형태로 관리돼 (그래서 “Link”가 있음).
  - 의도: malloc()을 반복 호출하지 않도록, 미리 확보해둔 공간에서 관리하려는 구조
    <img width="427" alt="Image" src="https://github.com/user-attachments/assets/59169ea6-30e8-4413-98a0-2e8c09b0e182" />

- 메모리 풀 확장 시 전략: 새 메모리 조각은 이전 메모리 조각보다 두 배 더 크다
  - 메모리 풀 안의 유휴 공간이 부족해지면, 새로운 메모리 조각을 요청해야 함.
  - 이때 새로 요청하는 조각은 항상 이전 조각보다 "두 배 크기"로 요청됨. malloc() 요청을 너무 자주 하지 않기 위함.
    <img width="509" alt="Image" src="https://github.com/user-attachments/assets/0c15fb88-533b-425f-a704-a0982058b6e7" />

<hr />

## 3.7. 대표적인 메모리 관련 버그

### 3.7.2. 포인터 연산의 잘못된 이해

- 주어진 배열의 합을 계산하는 코드

```c
int sum(int* arr, int len)
{
    int sum = 0;
    for (int i = 0; i < len; i++)
    {
        sum += *arr;
        arr += sizeof(int);  // ← 이게 문제
    }
    return sum;
}
```

- `arr += sizeof(int)` arr 포인터를 sizeof(int)번 만큼 "int 단위"로 이동시키는 게 아님. "sizeof(int) \* sizeof(int)" 바이트 만큼 이동하는 잘못된 계산
- C 언어의 포인터 연산 핵심 : arr + 1 는 메모리를 1바이트 이동하는 게 아니라 **"포인터가 가리키는 타입의 크기만큼 이동"**함.
- 즉, `arr++` 이 자체가 이미 `arr = arr + sizeof(int)` 와 같은 의미임. 그래서 추가로 sizeof(int)를 곱할 필요가 없음.
- 포인터를 이동할 때 데이터 형식의 크기를 신경 쓸 필요가 없다.

### 3.7.3. 문제 있는 포인터 역참조하기

- 다양한 메모리 영역을 파괴한 대가
  <img width="296" alt="Image" src="https://github.com/user-attachments/assets/a654feba-423a-4a56-8261-fa001fdad0bf" />

### 3.7.4. 초기화되지 않는 메모리 읽기

```c
void add() {
    int* a = (int*)malloc(sizeof(int));
    *a += 10;  // 초기화되지 않은 메모리에 접근
}
```

- malloc()은 메모리를 "초기화하지 않는다". malloc()은 할당만 수행하며, 해당 메모리를 0으로 초기화하지 않음. 초기 메모리 값은 이전에 사용되던 값이 남아있을 수 있음 → 예측 불가능한 값이 저장돼 있음.

- malloc 호출 시 두 가지 메모리 할당 경로

| 경로                                 | 설명                                                                                                                                                                |
| ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1. 기존 여유 메모리 사용**         | `malloc`은 내부적으로 확보된 여유 공간이 있으면 그 영역을 재활용함. 해당 영역은 과거에 다른 데이터가 있었을 수 있으므로 0이 아님                                    |
| **2. 운영체제로부터 새 메모리 요청** | 내부 여유 메모리가 부족할 경우, 시스템 호출(`brk`, `mmap`)을 통해 새 메모리를 요청함. 운영체제는 보안을 위해 이 메모리를 0으로 초기화하는 경우가 많음 (`zero page`) |

<hr />

## 3.8. 왜 SSD는 메모리로 사용할 수 없을까?

### 메모리 읽기/쓰기와 디스크 읽기/쓰기의 차이

- 주소 지정 단위 및 접근 방식의 한계

  - 메모리의 주소 지정 단위는 바이트로, 각 바이트마다 메모리 주소가 부여되어 있고, CPU가 이 주소를 이용하여 해당 내용에 직접 접근할 수 있다는 것을 의미함.
  - 하지만, SSD는 그렇지 않음. 조각 단위로 데이터를 관리하며 매우 다양한 크기를 갖고 있음. -> 바이트 단위 주소 지정이 지원되지 않는다는 의미

- 속도 및 지연 시간의 한계

  - RAM은 CPU 클럭에 맞춰 매우 빠르게 반응함.
  - SSD는 비교적 느리며, 컨트롤러, 큐잉, 파일 시스템 계층을 거쳐야만 데이터를 가져올 수 있음.
  - RAM과 SSD는 속도 단위가 1,000배 정도 차이 나는 수준임

- 쓰기 방식과 수명의 한계
  - SSD는 쓰기 전에 전체 블록을 지워야만 다시 쓸 수 있음 → 느리고 비효율적
  - RAM은 아무 주소나 곧바로 덮어쓰는 게 가능함
