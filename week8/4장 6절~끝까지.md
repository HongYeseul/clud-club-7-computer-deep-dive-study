# 4장 CPU 6절~끝까지

## 궁금한 점
- 마이크로코드가 복잡한 명령어 하나를 간단한 명령어 여러개로 만들었다는 의미?
- 하이퍼스레드는 사람이 값을 설정할 수 있는건가? CPU가 생산될 때부터 설계에 따라 고정되어있는건가?
- 351p 이해 안되는 부분 : 커널상태에서 사용자 상태 스택에 대응하는 커널 상태 스택을 찾은 후 여기에서 대응하는 커널 코드를 실행하여 시스템 호출 요청을 처리한다.
  -> 여기서 사용자 상태 스택이 메서드마다 존재하는 거니까 커널 상태 스택도 그만큼 존재하는 건가요..? 아니면 찾으면 그때 생기는 방식인가.. 

## 정리 

- CPU의 명령어
    - CPU의 명령어 종류는 CPU 하드웨어 설계에도 영향을 줌
    - 의미상 간격 : 당시 주로 사용되던 어셈블리어들과 그에 직접적으로 대응하는 기계 명령어 간의 간극
        
        이를 좁혀야 작업 효율과 메모리 저장공간 활용 효율이 높아진다고 생각했음
        
    - 폰 노이만 구조 : 코드도 메모리 공간을 차지함
    - 용어 정리하고 가기
        - 복잡한 명령어 : 명령어 당 CPU가 수행하는 연산이 많다는 의미
        - 단순한 명령어 : 명령어 당 CPU가 수행하는 연산이 적다는 의미

### 복잡 명령어 집합 CISC

- e.g.
    - x86구조의 CPU 들
    - 대표적인 제조업체 : 인텔, AMD
- 등장 배경
    1. 편리한 프로그램 작성
    2. 코드의 저장공간 절약
- 문제점
    - 직접연결 방식 : 명령어가 특정 조합회로로 직접 제어되는 방식. 명령어 집합의 변경에 대응 어려움
    - 마이크로코드 : 명령어에 자주 포함되는 연산 일부를 더 간단한 명령어로 구성된 작은 프로그램으로 정의한 것
        - 명령어가 추가되어도 하드웨어가 아닌 마이크로코드 수정 위주가 됨
        - 직접 연결 방식의 유연성 부족 문제 보완하기 위한 방법
        - 축소 명령어 집합의 장점을 수용했다는 말도 있음
- CISC 의 효과
    - 어셈블리어 프로그램 작성이 더 편리해짐
    - 프로그램 코드가 더 적은 저장공간 차지
    - 마이크로코드로 프로세스 HW 설계가 복잡해지는 문제도 극복

- 하지만 마이크로코드 설계의 단점이 커짐
    - 버그 발생 시 일반 프로그램코드 수정보다 마이크로코드 수정이 더 어려움 : 마이크로코드는 CPU 내부에서 명령어를 더 단순한 명령어로 변환하는 방식. 마이크로코드에 버그가 있어도 CPU바깥에 있는 컴파일러는 할 수 있는 일이 없음
    - 마이크로코드가 트랜지스터를 매우 많이 소모 : 성능향상을 위해 설계된 명령을 사용해도 CPU내부에서 마이크로코드에 의해 다른 명령어로 변환되어 효과를 잃음
    
    → 마이크로코드 자체가 해결해야 하는 문제로 여겨지게 됨
    

### 축소 명령어 집합 RISC

- CISC 가 마주했던 컴파일러 성능과 저장장치 용량제한의 문제가 기술이 발전되며 어느정도 해소됨
    
    → RISC 가 등장할 수 있었던 배경
    
- 80-20 법칙과 유사한 현상 : CPU는 약 80%의 시간동안 명령어 집합의 기계 명령어 중 20%를 실행함
    
    = 집중적으로 자주 사용되는 명령어들이 있음
    
- RISC 특징
    - 목적 : 복잡한 명령어 대신 단순한 명령어 여러개를 쓰자
    - 컴파일러가 기계명령어의 실행 세부사항 정보를 CPU로부터 제공받음 → CPU에 대해 더 강력한 제어권을 갖게 됨
    - 레지스터 내의 데이터만 처리함. 메모리에 직접 접근하지 않음. 메모리 접근 전용인 LOAD/STORE 명령은 별도로 다룸
- CISC vs RISC 차이
    - CISC : 적은 수의 명령어로 가능한 많은 작업 수행 (고급 언어와 유사한 특징). 프로그램 자체가 차지하는 공간 절약 가능. 명령어 길이가 가변적임
    - RISC : 간단한 명령어 여러개를 사용. 컴파일러가 기계 명령어를 자동으로 생성하게 하는 목적. 명령어 길이가 일정하여 컴파일러 최적화에 적합
    - 서로의 장점을 흡수하여 갈수록 차이가 줄어들고 있음
- 명령어 파이프라인
    - RISC 의 경우 각 명령어가 단순하여 실행 소요시간이 유사함 → 파이프라인 활용하기 좋음. 처리량 증가
    - 또한 마이크로코드가 없고 명령어 당 연산이 단순해 트랜지스터 절약 → 더 높은 클럭주파수 가짐. 성능 우수

### CISC 프로세서의 진화

- RISC 와의 차이로 인해
    
    한때 RISC 프로세서의 성능은 CISC 프로세서인 x86 인텔 제품에 비해 두세배 더 높았음
    
    그래서 CISC 프로세서 또한 변화하기 시작함
    
- 사용자에게 제공하는 명령어의 인터페이스만 유지하고, 내부 구현은 축소 명령어 집합(RISC)의 간단한 명령어들로 변환
    
    (껍데기만 CISC)
    
    → 호환성을 유지하면서 RISC의 장점을 얻음
    

- 하이퍼스레딩 (HW스레드)
    - 운영체제는 모름
    - 운영체제로 하여금 CPU 코어 수가 실제보다 많다고 인식하게 함
    - 명령어 간 종속성으로 인해 생기는 파이프라인 사이의 빈 공간을 활용. 명령어 처리흐름(스레드)를 추가하여 빈 시간을 채워 효율 극대화

### 두 CPU의 상업적 역사

- CISC 의 등장은 프로세서를 크게 발전시키고 x86 생태계를 확장함
- RISC 가 등장하고 성능에 격차가 컸지만 이미 훌륭한 x86 생태계와 x86 플랫폼에서 동작하는 수많은 소프트웨어들 존재
- RISC 를 활용한 소프트웨어들이 만들어질 시간동안 x86도 단점을 보완하고 RISC의 장점을 흡수하여 발전함. 다시 성능이 RISC 프로세서를 넘어서게 됨
- WinTel (Window + Intel) 연합이  CISC 프로세서 기반으로 컴퓨터 시장을 점령. 애플의 Macintoch 도 PowerPC 프로세서를 포기하고 인텔의 x86 도입
- ARM 으로 대표되는 RISC 진영은 임베디드와 저전력 영역으로 후퇴. 개방적 전략을 취한 CISC 에 반해 폐쇄적이었던 RISC 진영은 서버시장에서도 밀려 인텔 x86이 서버 시장 점령
- CISC 는 서버와 데스크톱 시장 모두에서 지배적인 위치가 됨
- 그러나 iPhone 이 등장하며 모바일 인터넷 시대 진입. 늦은 대응으로 인텔과 마이크로소프트는 밀려나고 ARM 프로세서가 시장 지배
- 애플은 모바일 프로세서 성장을 기반으로 높은 성능의 데스크톱 프로세서 M1 칩을 탄생시킴. ARM 기반
- 이런 과정을 거쳐 오늘날
    - CISC 기반 x86은 데스크톱 서버 영역을,
    - RISC 기반 ARM 은 모바일 시장을
    
    주도하며 공존하게 됨
    

→ 경쟁을 통해 서로의 장단점을 흡수하며 발전해온 결과임

## CPU에서 일어나는 작업들의 처리과정

### 1. 레지스터

- 메모리와 본질적으로 차이가 없음
- 더 빠르고 더 비쌈

### 2. 스택 포인터

- 모든 함수는 함수 스택프레임을 가짐. 호출 깊이가 깊어질수록 스택프레임수도 증가
- 스택 포인터 : 스택에서 가장 중요한 최상단 정보 저장
- 스택 하단을 의미함

→ 즉 스택 하단에 스택 상단 정보가 저장됨

### 3. PC (Program Counter, 명령어 주소 레지스터)

** x86 에서는 IP (Instuction Pointer, 명령어 포인터) 라 부름

- CPU가 다음에 실행할 명령어 주소의 메모리 주소 저장. CPU 의 실행 흐름을 결정
- 일반적으로 순차적으로 증가. 예외적으로 분기문 등의 명령어는 새로운 주소를 저장

### 4. 상태 레지스터 (Flag)

- 상태 레지스터에 저장되는 정보
    - 자리올림수(carry)발생
    - overflow 발생
    - CPU가 사용자상태와 커널상태 중 어떤 상태에 놓여있는지

### 5. 상황 정보

- 실행중이던 프로그램의 정보. 실행 중단 시에 이를 저장해두고 실행을 재개할 때 복원해옴
- 중단이 발생하는 상황
    - 함수 호출 : 함수 실행 점프
    - 시스템 호출 : 커널코드를 실행하기 위해 커널 상태로 전환
    - 스레드 전환 : 다른 프로그램의 기계 명령어 실행
    - 인터럽트 처리 : 인터럽트 발생 시 처리를 위해 실행중이던 프로그램 중단

### 6. 스택과 중첩

- 스택은 중첩구조를 처리하기 위해 탄생했음. FILO
- 처리 구조의 한가지. SW 로도, HW 로도 구현이 가능함
- 앞에서 언급한 프로그램 중단이 발생하는 상황은 모두 중첩구조임 → 스택으로 처리 가능!

### 7. 함수호출과 실행시간 스택

- 스택 프레임 : 모든 함수(메서드)는 독립적인 저장공간을 갖고 그곳에서 실행됨
- FILO 방식

### 8. 시스템 호출과 커널상태 스택

- 운영체제의 커널모드의 명령을 실행할 때는 사용자모드 스택 대신 커널모드 스택을 사용하여 처리함
- 과정
    - 시스템 호출 시 CPU가 커널 상태로 전환
    - 사용자모드 스레드에 대응하는 커널모드 스레드 찾음
    - 사용자모드 스레드에서 실행하던 상황정보를 커널모드 스택 가장 하단에 저장
    - 커널코드 스택에서 커널관련 코드 실행
    - 실행 종료 시 앞서 저장해둔 상황정보로 CPU를 사용자모드 전환

### 9. 인터럽트와 인터럽트 함수 스택

- ISR 스택이라는 인터럽트 처리 함수 스택이 존재하는 경우 그곳에서,
    
    없으면 커널 상태 스택에서 인터럽트 처리를 실행함
    
- 시스템 호출과 가장 큰 차이점은 인터럽트 처리는 주로 외부 장치에 의해 처리된다는 것!

### 10. 스레드 전환과 커널 상태 스택

- 스레드 전환 시 필요한 두가지 작업
    - 주소 공간 전환 (다른 프로세스를 실행해야 할 수 있으므로)
    - 상황정보 전환 (저장 및 복원)
        - 리눅스의 프로세스 서술자인 task_struct : CPU의 상황정보를 저장하는 구조체

---

- 더 알아볼 것
    - 폰 노이만 구조
    - 인터럽트 함수 스택 ISR 유무는 CPU마다 다른건가?
