## 컴파일러

코드를 컴퓨터가 알아들을 수 있는 기계 명령어로 변역하는 프로그램
소스코드를 입력하면 실행파일을 뱉어낸다
다양한 CPU가 이해할 수 있도록 CPU마다 상응하는 시뮬레이션 프로그램을 interpreter라고 함

컴파일러가 컴파일을 마치면 대상 파일(object file)을 만들어낸다. 하지만 이게 곧 실행파일은 아님.
여러 개의 대상파일을 합쳐서 하나의 실행파일을 만들어야 하는데, 이 과정을 링크(link)라고 함.

## 링커

링크 과정을 담당하는 프로그램. 컴파일러가 생성한 여러 개의 대상 파일을 하나의 최종 실행 파일로 생성하는 작업

링커 작업 과정
1. 다른 모듈에서 참조하는 변수나 인터페이스가 있는지 **종속성**을 확인한다.
참조하고 있는 외부 심벌이 실제 구현되어 있는지, 하나만 구현이 되어있는지 확인
2. 각 파일별로 확인을 거친 뒤에 하나로 모아서 실행파일 생성
3. 재배치 과정
컴파일러가 소스 파일을 컴파일 하는 시점에는 알 수 없었던 메모리 주소들을 실제 메모리 주소로 대체


- 지역 변수
    - 링커는 지역 변수 관심 없음
- 전역 변수
    - 전역 변수는 다른 모듈에서도 참조할 수 있음
 

 대상 파일에는 아래와 같은 두 가지의 영역이 포함되어 있음.

- 명령어 부분
    - 소스 파일에 정의된 함수에서 변환된 기계 명령어가 저장되는 부분. code 영역
- 데이터 부분
    - 소스 파일의 전역 변수가 저장되는 부분. 지역 변수는 스택 영역에서 생성되고 제거되기 때문에 별도로 저장하지 않는다.
 
컴파일러는 링커를 도와주기 위해서 소스파일마다 외부에서 참조 가능한 심벌이 무엇인지 이를 기록하도록 하는데, 이 표를 심벌 테이블이라고 한다.
만약 링커가 심벌을 찾지 못했다면 오류를 발생시킴.

- 심벌 테이블
    - 내가 정의한 심벌, 다른 모듈에서 사용할 수 있는 심벌
    - 내가 사용하는 외부 심벌
 

- 정적 라이브러리
    - 코드를 컴파일하고 패키지로 묶어서, 이 묶음을 제공
    - 소스 파일마다 단독으로 컴파일을 진행함
    - 이후 실행파일을 생성할 때는 라이브러리는 빼고 자신의 코드만 컴파일하면 됨. 이미 컴파일 된 정적 라이브러리는 컴파일할 필요가 없음
    - 다시 컴파일 없이 링크 과정에서 그대로 실행 파일에 코드 복사
    - 컴파일 속도 빨라짐(매번 컴파일 안해도 돼서)
    - 속도는 빨라지지만 디스크와 메모리 공간 낭비 가능성(필요할 때마다 실행 파일에 그대로 복사하기 때문에)
 
- 동적 라이브러리
    - 동적 라이브러리 이름, 심벌 테이블, 재배치 정보 등 필수 정보만 실행 파일에 포함
    - 라이브러리 내용을 모두 실행파일에 복사하는 정적 라이브러리 방식과 다름
    - 실행 파일의 크기를 줄일 수 있음

동적 링크의 두 가지 방식 
-  프로그램이 메모리에 적재될 때 동적 링크 진행
-  일단 프로그램 먼저 실행된 후, runtime에 코드가 직접 동적 링크 실행

동적 라이브러리의 장단점
- 장점
    - 메모리와 디스크 리소스를 아낄 수 있음
    - 라이브러리를 수정하더라도 라이브러리만 재컴파일 하면 됨. 내용 자체를 복사한 게 아니기 때문
    - 여러 언어를 혼합하여 개발할 때 유용
 
- 단점
    -  프로그램이 적재되는 시간 또는 실행 시간에 링크되기 때문에 성능이 떨어짐
    -  종속된 동적 라이브러리를 제공하지 않거나 그 버전이 호환되지 않으면 실행이 되지 않음
