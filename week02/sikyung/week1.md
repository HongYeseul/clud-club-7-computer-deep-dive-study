### 개요

전반적으로 컴파일 과정을 학습하며 이해했고, 특히 GCC 관련 개념이 혼동되어 해당 부분을 중점적으로 되짚어봤습니다.

### gcc 컴파일 과정

0. GCC(GNU Compiler Collection) 컴파일 과정 요약

- C 프로그램을 실행 가능한 바이너리 파일로 변환하는 과정은 4단계(전처리 → 컴파일 → 어셈블 → 링킹) 로 이루어진다.
- GCC는 각 단계에서 내부적으로 여러 툴을 사용하며, 이 과정에서 소스 코드 → 실행 파일이 만들어진다.

1. 전처리 단계 (Preprocessing) → cpp 실행

- 전처리기(cpp)가 #include, #define, #ifdef 등의 전처리 지시문을 해석 및 처리
- 매크로를 확장하고, 헤더 파일을 포함하며, 조건부 컴파일을 수행
- 최종적으로 **전처리된 C 코드(.i 확장자 파일)**를 생성

2. 컴파일 단계 (Compilation) → cc1 실행

- 전처리된 C 코드(main.i)를 **어셈블리 코드(.s 파일)**로 변환
- GCC의 실제 C 컴파일러(cc1)가 작동하여 C 코드를 어셈블리 명령어로 변환
- 이 과정에서 문법 오류 검사 및 최적화 수행

3. 어셈블 단계 (Assembly) → as 실행

- 어셈블리 코드를 기계어(바이너리)로 변환하여 오브젝트 파일(.o 확장자 파일) 생성
- GCC 내부의 어셈블러(as)가 실행됨
- CPU가 직접 실행할 수 있는 기계어 명령어가 포함된 바이너리 파일을 생성하지만, 독립 실행은 불가능 (링킹 필요)

4. 링킹 단계 (Linking) → ld 실행

- 링커(ld)가 실행되며, 여러 개의 오브젝트 파일(.o)과 라이브러리를 결합하여 최종 실행 파일을 생성
- 이 단계에서 표준 라이브러리(libc)와의 연결이 이루어짐
- printf() 같은 함수는 표준 라이브러리에서 가져와야 하므로, 링킹을 통해 실제 구현이 결합됨

### 결론: GCC 컴파일 과정 요약

1. 전처리(Preprocessing) → #include, #define 확장 후 C 코드 생성 (.i 파일)
2. 컴파일(Compilation) → C 코드 → 어셈블리 코드로 변환 (.s 파일)
3. 어셈블(Assembly) → 어셈블리 코드 → 기계어(오브젝트 파일) 변환 (.o 파일)
4. 링킹(Linking) → 오브젝트 파일을 실행 가능한 바이너리(main)로 결합

✅ C 코드는 바로 실행되지 않고, 반드시 4단계를 거쳐야 실행 파일이 된다! <br />
✅ 각 단계에서 중간 파일(.i, .s, .o)이 생성되며, 이를 활용해 디버깅 및 최적화 가능!

### 논의해볼 부분..

링커가 실제로 관심갖고 있는 것은 전역변수이다

1. 소스파일에 다른 모듈에서 참고할 수 있는 심벌 두개가 있다는 것
2. 소스파일이 다른 모듈에서 정의한 심벌 두개를 참조한다는 것 <br />
   ㄴ what...?
