# 1장 : 프로그래밍 언어부터 프로그램 실행까지 (컴파일러, 링커, 추상화)

---
### 궁금

- 자바는 패키지나 라이브러리를 언제 어떻게 불러올까 60p
    - JVM 의 클래스 로드 과정
        
        : 클래스 로딩 → 링크 → 초기화
        
        - 찾는 클래스가 없으면 `ClassNotFoundException` 발생
    - JVM의 클래스 로딩 방식
        1. `import` 문을 사용한 정적 로딩
            - 속도 빠름
        2. Reflection 또는 ClassLoader를 활용한 동적 로딩
            - Reflection 사용 시 성능 저하 가능성 (JIT최적화 적용 불가, 보안 검증 추가)
    1. 정적 로딩 : `import` 문 (컴파일 시)
        - 자바 컴파일러(`javac`)가 `import`된 클래스를 클래스 경로(CLASS_PATH)에서 찾아 .class 파일을 참조함
        - 실행 시점에는 이미 클래스를 JVM이 로드해둔 상태
    2. 동적 로딩 : Reflection 또는 ClassLoader를 이용 (런타임)
        - Class.forName() 및 ClassLoader 를 활용. JVM 이 로드
        - 설치된 라이브러리 여부에 따라 동작 변경 가능
        - 실행 시점에 "java.util.ArrayList" 클래스가 존재하면 동적으로 로드하는 코드
            
            ```java
            public class DynamicLoadingExample {
                public static void main(String[] args) {
                    try {
                        Class<?> clazz = Class.forName("java.util.ArrayList"); // 런타임에 로딩
                        Object obj = clazz.getDeclaredConstructor().newInstance();
                        System.out.println("클래스 로딩 성공: " + obj.getClass().getName());
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
            ```
            
        
- CLASSPATH 에 여러 경로 지정 시 우선순위는?
    - 구분자(; 또는 :)로 여러 경로를 지정할 수 있음
    - 지정 방법 2가지
        - 자바 실행 시 classpath 지정 옵션(-cp, -classpath)을 사용
            
            ```java
            // 윈도우
            set CLASSPATH=C:\myProject\classes;C:\myLib\myJar.jar
            
            //맥
            export CLASSPATH=/home/user/myProject/classes:/home/user/myLib/myJar.jar
            ```
            
        - 환경변수 CLASSPATH 로 지정
            
            ```java
            java -cp "C:\path1;C:\path2;C:\path3" MyApp
            ```
            
    - 옵션이 환경변수보다 우선순위가 높음
    - 구분자로 구분된 값들 중 앞쪽 값이 우선순위가 높음
    
- 중간코드에 추가적인 최적화가 진행되기도 한다.
    
    순환 구문 내 순환 상태와 관계없이 계산 가능한 값이 있다면 순환 구문 외부에서 먼저 진행하는 등의 처리 
    
    → ? 그런 경우가 언제지 46p

---
### 정리

- 저수준의 세부사항을 제어할 수 있는 고수준의 추상적인 표현
    - CPU 트랜지스터 → 기계 명령어 → (어셈블리어) → 고급 언어
    - 구문 syntax
        - 특정 작업 수행 명령 → 문(statement) 으로 정의
        - 상황에 따른 실행 → 조건문
        - 재귀와 반복 → 반복문
    - 구문 트리 : 모든 코드는 수열 표현식 또는 트리구조로 표현 가능
- 가상머신(인터프리터) : CPU 별 기계어로 변환
- 컴파일러
    - 추상적인 ‘구문’을 기계어(또는 바이트코드)로 번역하는 일 = 컴파일
    - 하나의 복잡한 프로그램일 뿐
    - 소스파일, 코드는 텍스트일 뿐
    - 소스파일 → (컴파일) → 실행파일(기계어 오브젝트파일 or 바이트코드)
        - 자세한 과정
            1. 구문분석 : 코드 → (어휘분석) → 토큰 → (해석parsing) → 구문트리
            2. 의미분석(semantic analysis) : 구문트리 검사. 컴파일 오류 검사
            3. 중간코드(IR Code) 생성, 어셈블리어 코드로 변환
            4. 어셈블리어를 기계어로 변환
- 심벌 : 모든 변수 이름. 링커의 관심사는 전역변수와 함수 이름.
- 링커의 링크 과정 : 컴파일과 런타임 사이를 이어주는 작업
    - 심벌 해석 : 종속성을 지닌 외부 심벌이 유일하게 존재하는지 확인
    - 재배치 : 컴파일 시 표시해둔 임시 주소를 찾아, 실제 메모리상 주소 삽입
    - 대상object파일에 포함되어있는 데이터 (컴파일러가 기록)
        - 코드 영역 : 소스파일로부터 변환된 기계어
        - 데이터영역 : 소스파일의 전역변수 (지역변수는 대상파일에 포함x)
        - 심벌 테이블 : 외부 심벌 정보. 공급 / 수요로 나누어 기록
        - .relo.text와 .relo.data : 컴파일 시점에 메모리 주소를 확정할 수 없는 변수 명령어의 위치와 관련 데이터 저장
        
        ** 실행파일에도 코드영역과 데이터영역이 존재함
        
- 라이브러리
    - 정적 : 소스파일을 개별적으로 미리 컴파일해두고 해더파일 제공. 정적 링크
        - e.g. .lib, .a
        - 컴파일 시 속도가 빠름
        - 라이브러리 내용을 직접 복사함. 공간 효율 떨어짐
        - 라이브러리 내용이 변경될 때마다 실행파일도 다시 컴파일해야 함
        - 동적 :
            - 라이브러리 필수정보만 실행파일에 포함함
            - 프로그램 실행 시점에 동적링크
            - 동적링크 방식 2가지
                1. 프로그램이 메모리에 적재(load)될 때 loader에 의해서
                2. 런타임에 코드가 직접 동적 링크 실행
                    
                    : 이 경우 실행파일에 라이브러리 정보 저장x
                    
            - 장점
                - 메모리 및 디스크 리소스 절약
                - 라이브러리가 수정되면 라이브러리만 다시 컴파일하면 됨. 수정 용이
                - 플러그인 등으로 런타임에도 쉬운 기능 확장
                - 라이브러리를 별도로 컴파일하므로 여러 언어를 혼합하여 사용 가능
                - 코드 재사용 효율성
            - 단점
                - 작은 성능 하락
                - 라이브러리를 임의의 메모리 절대주소로 참조할 수 없음 → ??
                - 실행파일 만으로 실행 불가. 종속된 동적 라이브러리를 제공해야함
- 가상메모리
    - 가상 메모리 - 물리메모리 간 위치 맵핑 : 사상(mapping)관계. 이를 기록한 것이 페이지 테이블. 페이지 테이블은 프로세스마다 가짐
    - 메모리구조(영역 순서)는 고정
    - 링커가 프로그램이 실제로 물리메모리 어디에 존재하는지 몰라도 되도록 해줌
    - 링커가 프로그램 실행파일만으로도 심벌의 실제 메모리 주소를 예측할 수 있게 해줌
    - 논리상으로만 존재함
- 추상화는 저수준의 세부계층을 몰라도 프로그래밍을 가능하게 해주지만, 제대로 다룰 줄 알려면 저수준까지의 이해를 갖추어야 함
