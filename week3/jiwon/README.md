# 2.1 스레드

## 1. CPU

- CPU는 스레드, 프로세스, 운영 체제 같은 개념을 알지 못함
    
    알고 있는 것
    
    1. 메모리에서 명령어를 하나 가져온다(dispatch)
    2. 이 명령어를 실행한 후 다시 1의 상태로 돌아간다.
- CPU가 메모리에서 명령어를 가져오는 기준 → 프로그램 카운터, 즉 PC라고 불리는 레지스터에 있음
- 레지스터 : 용량이 매우 작지만 매우 빠른 메모리의 일종
- PC 레지스터에는 메모리에 저장된 명령어 주소가 담겨 있음
    - 이때 저장된 명령어 주소는 CPU가 다음에 실행할 명령어임
- PC 레지스터가 저장한 주소는 기본적으로 1씩 자동 증가함
    - 대부분의 cpu는 주소를 1씩 증가시키면서 차례로 명령어를 실행함
    - 하지만, 조건에 따라 주소를 점프하기도 함
- 명령어는 메모리에 저장되어 있음

> 소스 파일 → 컴파일러 → 실행 파일 → 디스크 → 메모리 → CPU
> 
- 최초의 레지스터 값은?

### 2. CPU에서 운영체제까지

- 운영체제가 없다면
    1. 프로그램을 적재할 수 있는 적절한 크기의 메모리 영역을 찾기
    2. CPU 레지스터를 초기화하고 함수의 entrypoint를 찾아 pc 레지스터 설정
    - 이러한 과정을 수동으로 해야 함
- 수동의 단점
    1. 한 번에 하나의 프로그램만 실행할 수 있음
    2. 모든 프로그램은 사용할 하드웨어를 직접 특정 드라이버와 연결해야 하며, 그렇지 않으면 프로그램이 외부 장치를 전혀 사용할 수 없음
        1. 네트워크로 통신하려면 TCP/IP 스택 소스 코드에도 연결해야 함
    3. 기본 라이브러리가 없다
    4. 상호 작용 인터페이스를 직접 구현해야 한다.
- CPU는 한 번에 한 가지 일만 할 수 있음
    - 동시에 여러 프로그램을 실행하려면 빠른 전환으로 동시처럼 보이게 해야 함
- 전환은 저장된 상태, 즉 상황 정보(context)를 바탕으로 이루어짐
- CPU의 상황 정보를 저장하고 복구하는 구조체를 정의하여 전환에 사용
- 이러한 여러 기능의 프로그램을 모아둔 도구를 **운영체제**라고 함

## 3. 프로세스

> **프로세스 주소 공간** : 메모리 스택 → 여유 공간 → 힙 → 데이터 → 코드 영역 CPU
> 
- 다중 프로세스 프로그래밍은 여러 함수를 서로 다른 프로세스에서 실행시키고 결과 값을 합치는 방식
    - 프로세스 간 통신이 발생함
- 다중 프로세스 프로그래밍의 단점
    1. 프로세스를 생성할 때 비교적 큰 부담이 걸림
    2. 프로세스마다 자체적인 주소 공간을 가지고 있기 때문에 프로세스 간 통신은 프로그래밍하기 더 복잡함

## 4. 프로세스에서 스레드로 진화

- 프로세스는 entry funtion이 main 함수 하나 밖에 없어 프로세스의 기계 명령어를 한 번에 하나의 CPU에서만 실행할 수 있다는 단점이 있음
- 하나의 프로세스를 여러 CPU에서 사용하려면?
    - main 함수가 첫 번째 명령어 주소로써 레지스터에 기록되는 것은 그렇게 **실행 흐름**이 지정되어 있기 때문
        - **실행 흐름**은 커스텀이 가능함
    - 따라서 CPU 별로 **레지스터**에 실행 흐름을 다르게 지정하면 하나의 프로세스를 여러 CPU에서 동시 실행 가능함
        - 진입 함수를 다르게 한다는 의미
    - 이걸 바로 **스레드**라고 함
- 스레드 사이에는 통신이라는 개념이 존재하지 않음
    - 다른 스레드를 함께 사용하는 것은 동일한 프로세스 주소 공간에 속해 있기 때문임
    - 이러한 이유로 스레드를 **경량 프로세스**라고도 함
- 스레드의 수는 코어 수와 무관함
- 이러한 스레드의 편의성은 단점이 되기도 함
    - 다중 스레드가 공유 리소스에 접근할 때 오류가 발생하는 것
        - CPU가 명령어 실행 시, 스레드를 전혀 고려하지 않기 때문
        - 상호 배제, 동기화 고려가 필요함

## 5. 다중 스레드와 메모리 구조

- 함수가 실행될 때 필요한 정보 → 대응하는 스택 프레임에 저장됨
- 모든 함수는 실행 시 자신만의 실행 시간 스택 프레임을 지님
- 스택 프레임은 LIFO 순서로 증가하거나 감소하며 스택 영역을 형성함
- 스택 영역은 메모리 공간을 소모함

<스레드의 단점>

1. 스레드의 생성과 종료에 많은 시간을 허비할 수 있음
2. 스레드마다 각자 독립적인 스택 영역을 필요로 하기에, 많은 수의 스레드는 메모리와 기타 시스템 리소스를 많이 소모함
3. 스레드 수가 많으면 스레드 간 전환에 따른 부담이 증가함

⇒ 이를 해결하기 위해 **스레드 풀**(thread pool)이 등장함

## 7. 스레드 풀의 동작 방식

- 스레드 풀 : 스레드 여러 개를 미리 생성해 두고, 스레드가 처리할 작업이 생기면 해당 스레드에 처리를 요청하는 것
    - 생성과 종료 작업을 줄일 수 있음
    - 스레드를 재사용함
- 스레드 풀 내의 스레드에 작업을 전달하는 법
    - 자료구조의 대기열(producer- consumer)
- 스레드 풀에 전달되는 작업은 처리할 데이터, 데이터를 처리하는 함수 부분으로 구성됨
- 스레드 풀의 스레드는 작업 대기역에서 블로킹 상태로 대기함
    - 생산자가 작업 대기열에 데이터를 기록하면 스레드가 깨어남
    - 스레드는 작업 대기열에서 앞서 정의한 구조체를 가져와 구조체의 handle(데이터 처리 함수)이 가리키는 처리함수를 실행함
- 작업 대기열은 여러 스레드 간에 공유되는 리소스이므로 동기화 시, 상호 배제 문제를 해결해야 함

## 8. 스레드 풀의 스레드 수

- 스레드 풀의 스레드 수가 너무 적으면 CPU를 최대한 활용할 수 업스며, 너무 많은 스레드는 스레드의 단점을 그대로 갖게 됨
- 적당한 스레드 수?
    - 스레드 풀에서 처리할 작업이 어떤 것인지 알아야 함
        - CPU 집약적인 작업
        - 입출력 집약적인 작업
- CPU 집얍적인 작업
    - 외부 입출력에 의존할 필요 없이 계산을 처리할 수 있는 작업
    - 이 경우는 스레드 수와 CPU의 코어 수가 동일하면 충분함
- 입출력 집약적인 작업
    - 연산 부분이 차지하는 시간은 많지 않은 대신, 대부분의 시간을 디스크 입출력이나 네트워크 입출력 등에 소비하는 작업
    - 이 경우네는 성능 테스트 도구를 사용하여 WT(Wait Time)이라는 입출력 대기 시간과 CT(Computing Time)라는 CPU 연산에 필요한 시간을 평가해야 함
    - WT와 CT가 동일하다고 가정하면 대략 2N개의 스레드가 있어야 CPU 리소스를 최대한 활용할 수 있음

# 2. 스레드 간 공유되는 프로세스 리소스

> 프로세스는 운영 체제가 리소스를 할당하는 기본 단위고, 스레드는 스케줄링의 기본 단위이며, 프로세스 리소스는 스레드 간에 공유된다.
> 

## 1. 스레드 전용 리소스

- 함수의 실행 시간 정보는 스택 영역을 구성하는 스택 프레임에 저장됨
- 스택 프레임에는 함수의 반환값, 다른 함수를 호출할 때 전달되는 매개변수, 함수 내에서 사용되는 지역 변수와 레지스터 정보가 저장됨

![alt text](images/스택프레임과프로세스주소공간.png)

- 다음에 실행될 명령어 주소를 저장하는 PC 레지스터, 스레드 스택 영역에서 스택 상단 위치를 저장하는 스택 포인터 등 CPU가 기계 명령어를 실행할 때 내부 레지스터 값도 스레드의 **현재 실행 상태**에 속함
    - 이러한 정보들을 통틀어 **스레드 상황 정보**(thread context)라고 함
- 다른 스레드에서는 이런 레지스터 정보에 접근할 수 없음
- 이러한 전용 리소스 외에는 모두 스레드 간에 공유되는 리소스임

## 2. 코드 영역: 모든 함수를 스레드에 배치하여 실행할 수 있다.

- 프로세스 주소 공간의 코드 영역에는 컴파일한 후 생성된 실행 가능한 기계 명령어가 저장됨(실행 파일 = 코드 영역 + 데이터 영역)
- 코드 영역은  스레드 간에 공유됨
    - 따라서 특정 함수를 특정 스레드에서만 실행되도록 하는 것은 불가능함
- 코드 영역은 읽기 전용임 → 그래서 코드 영역에 관해서는 스레드 안전 문제가 없음

## 3. 데이터 영역 : 모든 스레드가 데이터 영역의 변수에 접근할 수 있다.

- 데이터 영역: 전역 변수가 저장되는 곳
- 프로그램이 실행되는 동안 데이터 영역 내에 전역 변수의 인스턴스는 하나임
    - 모든 스레드는 다 같은 인스턴스를 사용하기에 변경 시 모든 스레드에 적용됨

## 4. 힙 영역. 포인터

- malloc, new로 요청하는 메모리는 힙 영역임
- 모든 스레드는 포인터를 안다면, 포인터가 가리키는 데이터에 접근할 수 있음
- 따라서 힙 영역은 스레드 간 공유 리소스임

## 5. 스택 영역: 공유 공간 내 전용 데이터

- 스레드의 스택 영역은 구변되어 있지만 보호가 엄밀하지 않음
- 따라서 다른 스레드의 스택 프레임에서 포인터를 가져올 수 있다면, 해당 스레드의 스택 영역을 직접 읽고 쓸 수 있음
- 다른 스레드의 스택 영역에 속한 변수를 임의로 수정할 수 있는 것
- 편리하지만, 이런 스레드 간 느슨한 격리 작동 방식은 매우 어려운 버그가 발생할 수 있음

## 6. 동적 링크 라이브러리와 파일

- 링크는 컴파일 후 최종적으로 실행 파일을 생성하는 핵심적인 단계
- 정적 링크
    - 종속된 모든 라이브러리가 실행 파일에 포함되는 것
    - 모든 데이터가 포함되어 있기에 프로그램 시작 시 추가적인 작업이 필요하지 않음
- 동적 링크
    - 실행 파일에 종속된 라이브러리의 코드와 데이터가 없음
    - 프로그램 시작 시, 혹은 실행 중에 라이브러리를 찾아 프로세스 주소 공간에 넣어줘야 함
    - 그 데이터와 코드는 스택 영역과 힙 영역 중간의 여유 공간에 배치함
    - 이 부분은 모든 스레드가 공유하고 있음
    - 연 파일 정보도 저장되는데 이것도 공유 리소스임

## 7. 스레드 전용 저장소

1. 이 영역에 저장된 변수는 모든 스레드에서 접근할 수 있음
2. 모든 스레드가 동일한 변수에 접근하는 것처럼 보이지만, 사실 변수의 인스턴스는 각각의 스레드에 속함. 따라서 변경사항이 동기화되지 않음
- 즉 변수를 스레드 별로 독점적으로 사용할 수 있음

# 3. 스레드 안전 코드

## 1. 자유와 제약

1. 전용 리소스를 사용하는 스레드는 스레드 안전을 달성할 수 있습니다.
2. 공유 리소스를 사용하는 스레드는 다른 스레드에 영향을 주지 않도록 하는 대기 제약 조건에 맞게 공유 리소스를 사용하면 스레드 안전을 달성할 수 있습니다.

## 2. 스레드 안전

- 스레드 안전 : 코드가 스레드 몇 개에 호출되든, 스레드들이 어떤 순서로 호출되든 항상 올바른 결과가 나오는 것
- 이를 달성하기 위해 어느 것이 공유 리소스인지, 전용 리소스인지 구분해야 함

## 3. 스레드 전용 리소스와 공유 리소스

| 스레드 전용 리소스 | 공유 리소스 |
| --- | --- |
| 함수의 지역 변수 | 힙 영역 |
| 스택 영역 | 데이터 영역 |
| 스레드 전용 저장소 | 코드 영역(읽기 전용) |
- 코드 영역은 읽기 전용이라 크게 신경 쓰지 않아도 됨
- 공유 리소스를 사용하는 스레드는 순서를 유의해야 함
- **잠금**이나 **세마포어** 같은 장치를 사용하여 공유 리소스 순서를 유지할 수 있음

## 4. 스레드 전용 리소스만 사용하기

- 지역 변수(스레드 전용)만 사용하는 함수는 스택 영역에서 관리됨
    - 이러한 코드를 **무상태 함수**라고 함
    - 스레드 안전함
- call by value 매개변수는 스레드 전용 리소스임
    - 스택 영역에서 관리
- 하지만 call by reference(포인터)는 스레드 안전이 아님
    - 전역 변수를 가리키는 함수는 모든 스레드가 공유함
    - 잠금과 같은 형태의 순서 부여가 필요
    - 포인터가 힙 영역을 가리켜도, 동일한 변수를 가리키면 공유하는 리소스로 간주됨
    - 이를 해결하기 위한 방법
        
        → 함수 호출 시, 해당 스레드에 속하는 리소스 주소를 전달
        

## 6. 전역 변수 사용

- 전역 변수가 처음 프로그램이 실행될 때 한 번 초기화하고 나서, 모든 코드가 이 코드를 읽기만 하면 문제 없음(상수)
- 변수가 함수 실행 전 초기화되면 이후 실행 코드에서는 변경 불가

## 7. 스레드 전용 저장소

## 8. 함수 반환 값

## 9. 스레드 안전이 아닌 코드 호출하기

- 전역 변수를 사용하고 수정하더라도, 잠금으로 보호하면 스레드 안전이 될 수 있음

## 10. 스레드 안전 구현하기

- 다중 스레드 프로그래밍에서는 어떤 리소스라도 최대한 공유하지 않는 것이 원칙

<해결 방안>

1. 스레드 전용 저장소
2. 읽기 전용
3. 원자성 연산
    1. c++의 std::atominc 같은 변수
4. 동기화 시 상호 배제
    1. 공유 리소스의 순서를 유지시켜야 함
    2. 뮤텍스, 스핀 잠금, 세마포어 등의 방식이 있음
- 해당 챕터에서 말하는 스레드는 기본적으로 커널 스레드임
- 커널 스레드는 운영 체제가 관리함
    - 즉 프로그래머는 스레드의 생성과 스케줄링을 관여할 수 없음
- 운영 체제에 의존하지 않고 직접 구현하려면 코루틴으로 구현 가능함
    - 스레드보다 더 가벼운 실행 흐름

# 4. 코루틴

## 1. 일반 함수

- 일반 함수는 return 명령어를 만나거나, 코드의 마지막 줄까지 실행되어야 반환이 가능함

## 2. 일반 함수에서 코루틴으로

- 코루틴에는 스레드와 매우 유사한 일시 중지와 재개 기능이 있음
- 코루틴은 자신의 실행 상태를 저장할 수 있음
    - 그래서 반환된 후에도 계속 호출이 가능함
    - 마지막 일시 중단 지점부터 다시 실행할 수 있음

## 4. 함수는 그저 코루틴의 특별한 예

- 코루틴은 운영 체제가 스레드를 스케줄링 하는 것과 유사함
- 코루틴을 몇 개 생성하든 운영체제는 이를 알지 못함
- 코루틴은 온전히 사용자 상태 내에서만 구현된 것이기에 코루틴은 사용자 상태 스레드로 해석할 수 있음

## 5. 코루틴의 역사

- 코루틴은 사실 스레드 개념 이전부터 존재했음
- 이전에는 운영체제가 스레드를 운영한다는 개념이 없어서 코루틴을 사용함
- 현대에는 많은 데이터를 높은 성능과 동시성을 통해 제어하기 위해 코루틴을 사용함

## 6. 코루틴의 구현

- 힙 영역에 코루틴의 실행 시간 스택 프레임 정보를 저장하는 메모리를 요청할 수 있음
- 이때 스택 영역에는 여전히 함수 프레임을 보관함(일반 함수)
- 이론적으로 메모리 공간이 충분하면 코루틴 개수에 제한은 없음
- 코루틴은 프로그래머가 동기 방식으로 비동기 프로그래밍을 가능하게 함