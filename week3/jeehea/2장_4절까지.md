> 2장 1절~4절

## 궁금

- “가상메모리로 지금 사용하는 프로그램이 CPU와 표준 크기의 메모리를 독점하고 있다고 생각하도록 함” → 무슨 의미인지.. 특정 크기의 메모리 공간 사용을 보장받는다는 뜻? (실제 물리메모리에는 뿔뿔이 흩어져있는)
- 운영체제의 CPU와 스레드 스케줄링 방식?
    - 스케줄링 단위는 스레드인가?
    - 프로세스에 항상 최소 1개의 스레드가 있는건가?
- 스레드가 스택영역 공간을 나눠 쓰는 방법
- 동적 라이브러리 그래서 어디다 저장한다는 거지?? 스택과 힙 사이 여유공간?? 103p
- 118p 코드 잘 이해 안됨
- 119p 코드에서 락에 대한 스레드 안전도 고려해야하는 거 맞나?
- mutex, spin lock, semaphore  119p
- 코루틴의 상태정보는 왜 스택이 아닌 힙 영역에 저장될까?
    - 한 메서드에 종속되지 않는 전역 데이터라서? (힙이 전역변수 저장공간이므로)
- 일반함수와 코루틴은 형식상 차이가 없는데 어떻게 구분하지?
    
    → 일반함수도 코루틴의 일종일 뿐이므로 구분할 필요가 없음
    
- 코루틴은 코드 실행 흐름을 파악하기 어려울 것 같은데,
    
    코루틴이 언제 필요하지?
    
    → 2.8절에서 다시 보기
    

## 정리

### CPU 와 멀티태스킹

- CPU, PC 레지스터
    - CPU는 단순한 연산장치
    - 다음 실행할 명령어 주소는 레지스터 중 PC 레지스터에서 찾음
- 운영체제가 프로그램 실행 시 대신 해주는 여러가지 알들
    - 여러 프로세스 멀티태스킹
    - 하드웨어 연결
    - 라이브러리 제공

- 멀티태스킹 관점에서 보기
    - 멀티태스킹 : 빠르게 프로그램을 전환하며 실행. 중지했다가 재시작
    - 프로세스 : 재시작을 위해 저장해놓은 프로그램 실행 상황 데이터
    - 운영체제 : 프로세스 스케줄링 관리도구 (다른 역할도 많지만)

- 다중 프로세스 프로그래밍 : 프로세스를 나눔
    - 프로세스 간 통신 문제 존재
    - 프로세스 생성 오버헤드
- 멀티스레딩 : 한 프로세스에 스레드(실행흐름) 여러개
    - 한 프로세스 내에서 일어나므로 데이터 공유 (통신 불필요)
    - 가벼움
    - 스레드 간 공유 리소스 문제 처리 필요

### 스레드

- 스레드
    - 스레드는 운영체제 계층에 구현. CPU 코어 수와 무관
    - CPU 는 스레드를 알지 못함
    - 생성 시 진입함수를 지정. CPU 가 진입함수 주소로 실행 시작
    - 프로세스 주소공간에서 스택 영역을 나누어씀. 나머지 (코드, static데이터, 힙)는 공유
- 스레드 풀
    - 스레드 생성 오버헤드를 줄이기 위해, 일정량의 스레드를 미리 생성해뒀다가 재사용함
    - 대기열(큐)을 사이에 둔 생성자-소비자 패턴으로 스레드풀의 스레드에 작업을 할당
    - 적절한 스레드 수
        - CPU 집약적인 작업의 경우 : 일반적으로 CPU 코어 수와 동일하면 적절
        - 입출력 집약적인 작업의 경우 : 적절값을 계산하는 이론은 있지만 절대적이지 않으므로 실제 테스트를 통해 찾는 것을 권장

### 스레드 안전과 스레드 공유 리소스

- 스레드 공유 리소스
    - 코드영역 : 읽기 전용. thread safe
    - 데이터(static) 영역 : 스레드 공유 리소스
    - 힙 영역 : 스레드 공유 리소스. 포인터에 의해 여러 스레드에서 접근 가능
    - 스택 영역 : 스레드 공유 리소스. 스레드별 스택영역이 구분되어있긴 하지만 접근을 제한하지는 않아서 접근 가능함
- 스레드 전용 저장소 : 스레드 전용 변수로 선언 시 인스턴스가 각각의 스레드에 복사되어 사용됨 (c 예시 : `__thread in a = 1;`)

- 스레드 안전
    - 그 코드가 스레드 몇 개에서 어떤 순서로 호출되는지 상관없이 올바른 결과가 나옴
    - 공유 문제가 발생할 경우, 락이나 세마포어 등으로 보호해야 함
- 스레드 안전 코드 구현 방안
    - 스레드 전용 저장소 사용
    - 읽기 전용
    - 원자성 연산(atomic)으로 처리
    - 동기화 시 상호배제 (mutex, spin lock, semaphore 등 사용)

### 코루틴

- 스레드와 코루틴의 차이
    - 스레드 (커널 스레드) : 운영체제가 관리
    - 코루틴 (사용자 상태 스레드) : 사용자가 코드상으로 관리. 스레드보다 가벼움. 반환 및 재개 지점을 설정

- 코루틴
    - 자신의 실행상태를 저장해둘 수 있음
    - 반환 및 재개지점을 만나면 저장해두고, 해당 코루틴이 재호출 되었을 때 그 지점부터 실행 재개
    - e.g. 파이썬 : yield 키워드로 반환 및 재개지점을 지정
    - 코루틴의 상태정보는 힙 영역에 저장됨
    - 동기 방식으로 비동기 프로그래밍을 가능하게 함 (2.8절에서 다시 설명)

- 일반함수, 스레드와 비교
    - 일반 함수와 형식상 차이가 없음. 일반함수는 재개지점이 0개인 코루틴과 동일(코루틴의 일종)
    - 가벼운 스레드같다고 함 : 실행 중 정지 및 재개가 가능하다는 점이 운영체제가 스레드를 스케줄링하는 것과 유사. 스케줄링 제어권이 사용자에게 있는 스레드
    - 코루틴은 스레드가 없던 시절에 사용되던 기술로, 스레드 등장 후 사용되지 않다가 높은 동시성 및 성능을 처리하기 위해 조명받음
