### 1. 프로세스의 메모리 영역 및 스레드 간 공유 특성 요약

| 메모리 영역                      | 스레드 간 공유 여부         | 주요 특징                                                                      |
| -------------------------------- | --------------------------- | ------------------------------------------------------------------------------ |
| **코드(Code) 영역**              | 공유됨                      | 실행 코드 저장, Read-Only, 스레드 안전(Thread-Safe)                            |
| **데이터(Data) 영역**            | 공유됨                      | 전역/정적 변수 저장, 동기화 필요                                               |
| **힙(Heap) 영역**                | 공유됨                      | 동적 할당 메모리 저장, 포인터 기반 접근 가능, 동기화 필요                      |
| **스택(Stack) 영역**             | ❌ 기본적으로 스레드별 독립 | 함수 호출 정보, 지역 변수 저장, 직접 접근 불가능(포인터를 통한 간접 접근 가능) |
| **동적 링크 라이브러리 및 파일** | 공유됨                      | 공유 라이브러리 코드/데이터 및 열린 파일 정보 저장                             |
| **스레드 전용 저장소 (TLS)**     | ❌ 공유되지 않음            | 스레드별 독립적 변수 유지                                                      |

### 2. 코루틴

1. 정의: 코루틴은 사용자 상태(user mode) 스레드로, 이전 실행 상태를 기억하고 있다가 중단된 지점에서 다시 실행할 수 있는 함수가 있다. 이를 통해 하나의 프로세스에서 여러 실행 흐름을 처리할 수 있다. 커널 스레드를 사용하지 않고도 동시성을 구현할 수 있는 방식이다. 코루틴은 실행 흐름을 일시 중지하고, 나중에 다시 시작할 수 있기 때문에, 제어 흐름을 유연하게 관리할 수 있다.

2. 역사: 코루틴은 커널 스레드가 없던 시절, 효율적으로 동시성 프로그램을 구현하기 위해 고안된 오래된 기술이 있다. 1970년대와 1980년대 초기 프로그래밍 환경에서 고안되었으며, 그 당시에는 운영 체제가 멀티스레딩을 지원하지 않았기 때문에 코루틴을 사용해 동시성을 구현해야 했다.

3. 구현 방법:

- 코루틴은 스레드와 본질적으로 다르지 않지만, 운영 체제의 개입 없이 사용자가 직접 스케줄링을 관리한다.
- 코루틴이 일시 중지될 때, 저장되는 상태 정보에는 CPU 레지스터와 함수 실행 시 상태 정보가 있다.
  - 일반 함수의 상태 정보는 프로세스 주소 공간 중 스택 영역에 저장된다.
  - 코루틴의 상태 정보는 힙 영역에 저장된다. 이는 코루틴이 동적 메모리를 사용하여 상태를 관리할 수 있게 해준다.
- 코루틴은 스레드와 달리, 커널의 개입 없이 사용자 수준에서 스케줄링되고 전환된다.

4. 장점:

- 사용자 수준 스케줄링: 코루틴 간 전환/스케줄링은 사용자 상태에서만 처리되므로, 커널의 개입 없이 더욱 효율적으로 실행 흐름을 전환할 수 있다. 이는 커널 스레드에 비해 메모리와 CPU 사용을 줄여주는 이점이 있다.
- 가벼운 상태 저장: 코루틴 간의 전환 시 저장되고 복구되는 정보가 커널 스레드보다 가볍기 때문에, 빠른 전환이 가능하다. 이는 저비용 비동기 프로그래밍을 가능하게 한다.
- 동기식 비동기 프로그래밍: 코루틴은 동기적인 코드처럼 보이지만, 비동기적으로 시간을 분할하여 실행할 수 있게 해준다. 예를 들어, I/O 작업을 처리할 때 동기적인 흐름을 유지하면서도, 비동기적으로 작업을 병렬 처리할 수 있게 해준다.
- 프로그램 흐름 제어: 코루틴을 사용하면 동시성을 처리하면서도 동기적인 코드 흐름을 유지할 수 있기 때문에, 가독성이 높고 디버깅이 쉬운 코드를 작성할 수 있다.

5. 단점:

- 코루틴은 스케줄링의 제어를 사용자가 담당하므로, 잘못 관리되면 스케줄링 문제(예: 데드락, 무한 루프 등)가 발생할 수 있다.
- 스레드와의 혼동: 멀티스레딩과 비교했을 때, 코루틴은 스레드처럼 병렬 실행되지 않는다. 대신, 단일 스레드에서 여러 실행 흐름을 처리하는 방식이다. 따라서 실제 병렬 처리가 필요한 경우, 스레드를 사용하는 방법이 더 적합할 수 있다.
