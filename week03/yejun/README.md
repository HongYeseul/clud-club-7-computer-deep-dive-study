## 프로그램이 실행되었지만, 뭐가 뭔지 하나도 모르겠다
___

### 운영체제
- 프로그램을 자동으로 적재, 멀티태스킹을 실현 해주는 역할을 함
- 운영체제가 없이 cpu가 프로그램을 실행하도록 할 수 있지만, `적절한 메모리 영역 찾기, pc 레지스터 설정, 네트워크 스 등등 매우 불편`
- 지금 사용하는 프로그램이 cpu와 물리 메모리를 독점하고 있다고 생각할 수 있게 해줌 -> 가상 메모리 등의 추상화
___
### 프로세스
cpu가 어떤 기계 명령어를 실행했는지와 cpu내부 기타 레지스터 값 등 상태값을 저장해둔 구조체를 프로세스라 한다.

이 정보로 프로그램을 일시 저장했다가도 프로그램 실행을 재개할 수 있어서 멀티 태스킹이 가능하다.

- 프로세스 주소 공간
  - 운영체제의 가상 메모리는 각 프로세스가 표준적인 메모리 크기를 독점적으로 사용하는 것처럼 보이게 함
  - 코드 영역
  - 데이터 영역
  - 힙 영역
  - 스택 영역

다중 프로세스 프로그래밍 단점

상황: afunc이 bfunc의 결과를 필요로 할 때
- 프로세스 생성 시 **오버헤드**
- 프로세스 마다의 자제척 주소 공간으로 **프로세스 간 통신**은 더 복잡함
- 프로세스 단점
  - 진입 함수가 main 하나 밖에 없어서 프로세스의 기계명령어를 한 번에 하나의 cpu에서만 실행 가능
  - cpu 여러대가 동일한 프로세스의 기계명령어를 실행하게 할 방법은??
  - pc레지스터가 진입 함수로 main을 지정한 것과 동일한 방식으로 pc레지스터가 다른 함수를 지정하고 이를 통해 새로운 실행 흐름을 형성할 수 있음

![image](https://github.com/user-attachments/assets/6e8cec01-89f0-44d9-be22-44660571861c)
___
### 스레드

pc레지스터를 통해 하나의 프로세스에 두개 이상의 진입 함수를 설정하여(afunc, bfunc) cpu 여러개가 동시에 프로세스의 기계 명령어를 실행할 수 있다.

- 공유 프로세스 주소 공간에서 동일한 프로세스에 속한 기계 명령어를 동시에 실행 가능
- 하나의 프로세스 안에 여러 개의 실행 흐름 존재 가능

![image](https://github.com/user-attachments/assets/df5b44dc-1a13-4812-861f-eb7340f6dcaa)


- 하나의 프로세스 내에서 이루어지므로 프로세스 간 통신이 필요없음
- 프로세스 내의 스레드들은 변수들을 공유 => 자신이 속해 있는 프로세스 주소 공간을 공유한다는 의미
- 스레드 덕분에 프로세스를 시작하고 스레드를 여러개 생성하여 모든 cpu를 최대한 사용하여 다중 코어를 충분히 이용할 수 있게 된다

___

### 다중 스레드
스레드는 운영체제 계층에 구현되어 코어 개수와 무관. cpu가 기계명령어를 실행할 때도 어느 스레드에 속하는지 인식 못함

- cpu가 명령어를 실행할 때 스레드 고려 않기 때문에 공유 리소스 접근 시 버그 발생 가능성이 있음
- 상호배제와 동기화 이용하여 개발자가 명시적으로 해결해야함

#### 다중 스레드 메모리 구조

스택 프레임
- 함수 실행 시 필요정보
- 매개변수, 지역변수, 반환주소 등

스택 프레임의 증감이 프로세스 주소 공간에서 스택 영역을 형성함

스레드가 실행될 때 해당 정보를 저장하기 위해 스택영역이 여러개 필요

각 스레드는 프로세스 주소 공간에 자신만을 위한 스택영역을 갖고 있으며 스레드를 생성하면 프로세스의 메모리 공간이 추가적으로 필요함

![image](https://github.com/user-attachments/assets/500e6401-f5dc-476b-9a6e-9fd12a88ad42)


수명 주기 관점에서의 긴 작업과 짧은 작업

긴 작업: `워드 문서 편집`

짧은 작업: `웹, 디비, 파일 등`
두가지 특징
- 작업 처리 필요 시간 짧음
- 작업 수가 매우 많음
- 요청 당 스레드 방식 (서버가 하나의 요청을 받으면 해당 작업 처리하는 스레드 생성, 처리 완료되면 스레드 종료)
  
**짧은 작업엔 부적합**
- 스레드 생성 종료 오버헤드
- 스레드마다 독립적인 스택영역이 필요하므로 메모리와 기타 시스템 리소스 많이 소비
- 스레드 전환 오버헤드

=> 요청 당 스레드 방식 단점 해결 위해 스레드 풀이 탄생됨
 
#### 스레드풀

- 스레드 재사용이 핵심
- 스레드 여러개를 미리 생성해두고 작업 생기면 해당 스레드에게 요청
- 스레드 생성 및 종료가 빈번하지 않으며 스레드 개수 관리되므로 메모리 안정적
- 스레드풀 내에 있는 스레드에게 작업 전달하기

**큐 자료구조 (생산자 소비자 패턴)**

![image](https://github.com/user-attachments/assets/9735980a-2f49-4498-87cf-dcf983f9b94c)

스레드풀에서 적당한 스레드 개수

cpu 집약 작업 vs i/o 집약 작업
- cpu 집약 작업은 외부 입출력 필요 없으므로 스레드 수와 cpu코어 수 같다면 cpu리소스를 충분히 활용 가능
- i/o 집약작업은 성능 테스트 도구로 입출력 대기시간과 cpu연산 시간 평가 필요 -> 실상황으로 테스트하여 대응
___
#### 스레드간 공유되는 프로세스 리소스

운영체제가 제공하는 두가지 추상화 개념
- 프로세스는 운영체제가 리소스를 할당하는 기본 단위
- 스레드는 스케줄링 기본단위, 프로세스 리소스는 스레드간 공유됨

**스레드 개별 전용 리소스 (스택영역)**

상태변화 관점에서 스레드는 사실 함수를 실행하는 것 -> 함수 실행에는 항상 하나의 시작점이 존재한다.

cpu는 진입 함수에서 실행 시작하여 실행 흐름(스레드) 생성

함수 실행에 필요한 정보는? (함수의 런타임 정보는 개별 스택 영역을 구성하는 스택 프레임에 저장)
- 반환값
- 매개변수
- 지역변수
- 레지스터 정보
- pc 레지스터
- 스택 포인터

코드 영역, 데이터 영역, 힙 영역

스택 영역은 스레드 별 전용 리소스 공간
코드영역 : 모든 함수는 스레드에 배치될 수 있음

어떤 함수든 모두 스레드에 적재하여 실행될 수 있음

특정 함수를 특정 스레드에서만 실행되도록 하는 것은 불가

- 스레드는 다른 스레드 영역을 주소로 참조하여 건드릴수 있고, 힙 영역, 데이터 영역의 변수 주소를 공유하면 여러 스레드가 공유 리소스에 작업을 하는 상황이 발생하는 것이다.

#### Thread Safe

어떤 코드가 주어졌을 때 그 코드가 스레드 몇 개에서 호출되든 어떤 순서로 호출되든 올바른 결과가 나온다면 스레드 안전
- 전용 리소스만 사용하는 스레드는 스레드 안전을 달성할 수 있음
- 공유 리소스 사용하는 스레드는 대기 제약 조건에 맞게 리소스 사용하면 스레드 안전 달성
스레드 안전 코드 작성하는 방법?
- 어떤 것이 스레드 전용 리소스고 어떤 것이 공유 리소스인지 구분할 수 있어야함
- 스레드 안전을 위해 공유 리소스 사용 스레드는 순서를 따라야함
  - 순서의 핵심은 공유 리소스를 사용하는 작업이 다른 스레드를 방해할 수 없다는 것
  - 락이나 세마포어 같은 장치를 사용하여 공유 리소스 순서를 지킬 수 있음

![image](https://github.com/user-attachments/assets/d0f3fdd5-25b6-40c9-aae5-cba10ba33dd6)

**리소스 공유 필요한 경우라면?**
- 스레드 전용 저장소
- 읽기 전용
- 원자성 연산 방식으로 사용
- 동기화 시 상호 배제 -> 뮤텍스, 스핀락, 세마포어 등을 활용하서 순서 보장
___

### 코루틴
스레드보다 더 가벼운 실행 흐름

일반함수는 return 명령어를 만나거나 코드의 마지막 줄까지 실행되어야 반환이 가능

일반 함수는 반환된 후 스택 영역에 정보 저장 하지 않음

코루틴은 스레드와 매우 유사한 기능인 일시 중지와 재개 기능이 존재

![image](https://github.com/user-attachments/assets/6673e69b-418a-495f-a5a4-d0972ab27ed5)

코루틴은 자신의 실행 상태 저장 가능

코루틴 반환된 후에도 이어서 계속 호출이 가능하며 마지막으로 일시중지된 지점에서 이어서 실행됨

반환된 후에도 함수 실행시의 정보 저장 필요, 다시 실행될 때 해당 정보가 필요함

코루틴은 자신이 마지막으로 실행된 위치를 알 수 있다는 점에서 일반 함수와 다르다
- 전용 리소스만 사용하는 스레드는 스레드 안전을 달성할 수 있음
- 공유 리소스 사용하는 스레드는 대기 제약 조건에 맞게 리소스 사용하면 스레드 안전 달성

![image](https://github.com/user-attachments/assets/d33d055e-3f8e-424f-9113-9154c46af6c0)

코루틴 vs 일반함수
`일반 함수는 연결 시작 지점이 존재하지 않는 코루틴에 불과하다`
코루틴은 어떻게 구현되는가 -> 스레드 구현과 동일한 구조
- 일시 중지되고 다시 시작할 수 있어야함
- 일시중지 될 때의 상태정보를 반드시 기록해야함
- 런타임 스택프레임 정보
- cpu 레지스터 정보
- 함수 실행시 상태 정보
**스레드는 이를 프로세스 주소 공간의 스택영역에 저장함**

**코루틴은 런타임 스택 프레임 정보를 힙영역에 저장**

메모리가 충분하다면 코루틴 개수에 제한 없으며 코루틴 간 전환도 가벼워 효율이 좋으며

개발자가 동기 방식으로 비동기 프로그래밍을 가능하게 함
