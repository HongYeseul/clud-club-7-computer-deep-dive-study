# 5. 메모리 할당 시 저수준 계층에서 일어나는 일

- 저수준일수록 cpu의 영향력은 커짐
  - 일반적으로 사용자 상태(3단계), 커널 상태(0단계)에서만 사용

## 커널 상태

- cpu가 **운영 체제**의 코드를 실행할 때
- cpu가 모든 기계 명령어를 실행할 수 있으며, 모든 주소 공간에 접근할 수 있음
- 제한 없이 하드웨어에 접근할 수 있음

## 사용자 상태

- 프로그래머가 작성한 일반적인 코드를 cpu가 실행할 때(프로세스 접근)
- 제한이 있으며, 특히 특정 주소 공간에는 절대 접근할 수 없음
  - 세그먼테이션 오류 방지

###

- cpu는 커널 상태에서는 응용 프로그램을 실행할 수 없지만, 사용자 상태에서는 운영 체제의 코드를 실행할 수 없음
  - 어느 한 쪽이 포함하는 관계가 아니라, 나뉘어져 있음
- 프로그래머가 시스템 호출을 하면, 운영 체제가 파일 읽기 쓰기, 네트워크 데이터 통신 같은 작업을 응용 프로그램 대신 처리해줌
  - 시스템 호출을 실행할 때는 커널 상태로 전환되어 운영 체제의 코드를 수행함
- 시스템 호출 코드를 별도로 담아 둔 이유?
  - 직접 시스템 호출을 사용하면 여러 운영체제에 호환되지 못함
  - C 언어에서는 표준 라이브러리가 이 역할을 수행
- 응용 프로그램은 일반적으로 표준 라이브러리만 의사소통 대상으로 간주
- 포준 라이브러리는 시스템 호출로 운영 체제와 소통하고, 운영 체제는 저수준 하드웨어를 관리함

### 힙 영역의 메모리가 부족할 때

- 메모리 할당자 안의 여유 메모리 조각이 부족해지면 스택 영역과 힙 영역 사이의 유휴 영역의 메모리를 점유하여 사용함
  - 리눅스의 모든 프로세스에는 brk 변수가 있음
    - brk는 힙 영역의 최상단을 가리킴
  - 이 brk 변수의 시스템 호출을 통해 힙 영역의 크기를 조절함
- 실제로 할당한 메모리가 사용되는 순간에 물리메모리가 할당됨
- 가상 메모리를 사용할 때는 실제 물리 메모리와 사상 관계에 있어야 함

### 메모리 할당 과정

1. 여유 메모리 탐색하여 할당
2. 적절한 여유 메모리가 없으면 brk 같은 시스템 호출을 통해 힙 영역 확장하여 더 많은 여유 메모리 얻음
3. brk 호출 시 커널 상태로 전환되는데, 이때 운영 체제의 가상 메모리 시스템이 힙 영역을 확장하는 작업을 시작. 이렇게 확장된 메모리 영역은 가상 메모리에 불과하며, 운영 체제는 아직 실제 물리 메모리를 할당하지 않았을 수 있음
4. brk 실행이 종료되면 malloc으로 제어권이 돌아가며 cpu도 사용자 상태로 전환됨
5. 코드가 새로 요청된 메모리를 읽거나 쓰면 시스템 내에서 페이지 누락 인터럽트가 발생. cpu는 다시 커널 상태로 전환되어 운영 체제가 실제 메모리를 할당하기 시작. 페이지 테이블 내 가상 메모리와 실제 물리 메모리의 사상 관계가 설정된 후, cpu는 다시 사용자 상태로 돌아가서 진행.

⇒ 즉 가상 메모리 할당과, 물리 메모리 할당은 별개의 단계로 동작

## 6. 고성능 서버의 메모리 풀

- 메모리 풀 : 특정 상황을 위한 자체적 메모리 할당 전략 구현을 위한 기술
- 범용 메모리 기술은 표준 라이브러리, 메모리 풀은 응용 프로그램 계층에 위치
- 메모리 풀 기술의 설계 구현은 비교적 간단하지만 범용성이 매우 떨어짐

### 메모리 풀 기술의 원리

- 한 번에 큰 메모리 조각을 요청하고 그 위에서 자체적으로 메모리 할당과 해제를 관리하는 방식으로 표준 라이브러리와 운영 체제를 우회함
- 특정 사용 패턴에 따라 추가적인 최적화도 가능
    - 메모리 풀에 미리 특정 객체를 생성해두고 사용할 수 있음

### 초간단 메모리 풀 구현

- 다양한 방법이 있지만 메모리 풀에 미리 객체를 생성해두고 메모리 요청 시 반환, 반납하는 방법이 있음
  - 모든 작업이 완료되고 한 번에 할당을 해제할 수도 있음
- 메모리 풀의 설계는 특정 상황에만 적용할 수 있음

### 약간 더 복잡한 구현

- 여러 크기의 메모리를 할당하기 위해서는 여유 메모리 조각을 관리하여야 함
- 모든 메모리 조각을 연결 리스트로 연결하고 포인터를 사용하여 현재 여유 메모리 조각의 위치를 기록할 수 있음
- malloc에 새로운 메모리 조각을 요청할 때에는 항상 이전 메모리 조각의 두 배를 요청해야 함
  - 메모리 요청이 너무 빈번하지 않기 위해
- 메모리 풀은 malloc이 반환한 메모리 위에 재할당 됨
- 메모리 풀의 여유 메모리 조각의 시작 위치를 가리키는 포인터를 이용하여 빠르게 검색 가능
- free처럼 메모리 조각 해제를 지원하지 않고, 전체 메모리 풀을 해제해야 하는 것이 특징

### 메모리 풀의 스레드 안전

- 잠금은, 올바른 작동은 가능하겠지만 잠금 경쟁이 격렬해질 수 있음
- 스레드마다 메모리 풀을 유지하여 스레드 간 경쟁 문제를 근본적으로 해결하는게 좋음
  - 스레드 전용 저장소에 스레드 풀을 넣어 사용

### 

- 스레드 전용 저장소를 사용할 때, A 스레드의 수명 주기를 넘어서 A의 실행 후에도 다른 스레드에서 해당 메모리를 사용해서 스레드 B에서 이를 해제해야 한다면?
  - A 스레드 종료 전, 다른 스레드에 저장 내용 전달
  - A 메모리의 해제 책임을 B 스레드에 위임
    - A 전용 스레드의 데이터를 전역 큐나 공유 메모리에 일시적으로 저장하고, B가 이를 사용한 뒤 해제

## 7. 대표적인 메모리 관련 버그

1. 스택 프레임에 저장된 지역 함수를 호출하고 종료된 후, 다시 호출할 때
    1. 오류가 없을 수 있지만, 스택 프레임이 덮어 씌워지거나, 파괴될 수 있음
2. 포인터 연산 오류
    1. 포인터 연산에서 1을 더하는 것은, 1바이트 만큼 이동하는 것이 아니라 단위 한 개 만큼 이동하는 것임(데이터 형식의 크기)
    2. 그래서 arr += sizeof(int)가 아니라 arr++를 하면 됨(크기를 신경쓰지 않아도 알아서 적용됨)
3. 잘못된 포인터 역참조

    ```bash
    int a;
    scanf("%d", a);
    ```

    1. a가 코드 영역이나, 기타 읽기 전용 영역을 가리키는 포인터 값으로 해석
        1. 운영체제는 이 프로세스를 즉시 강제 종료함
    2. a가 스택 영역을 가리키는 포인터 값으로 해석
        1. 다른 함수의 스택 프레임이 파괴됨(최악)
    3. a가 힙 영역 또는 데이터 영역을 가리키는 포인터 값으로 해석
        1. 프로그램이 동적으로 할당한 메모리가 파괴됨(최악)
4. 초기화되지 않은 메모리
    1. 힙 영역에서 동적으로 할당된 메모리가 항상 0으로 초기화되진 않음
    2. malloc이 자체적으로 충분한 메모리를 유지하고 있으면, 여유 메모리 조각에서 반환할 주소를 찾음. 이전에 사용한 정보때문에 0이 아닐 수 있음
    3. malloc이 자체적으로 메모리가 부족하면 brk 같은 시스템 호출로 운영체제에 메모리를 요청. 메모리에서 실제 사용 시 page fault 발생하며, 운영체제가 실제 물리 메모리를 할당하기에 0으로 초기화될 수도 있음
    4. 따라서 이전 정보를 불러와버릴 수 있으니 초기화가 필요하다~
5. 이미 해제된 메모리 참조
    1. 메모리 조각이 해제된 후 아직 malloc으로 다시 할당되지 않았으면 이전 값과 동일
    2. 메모리 조각이 이미 재할당 되었다면 덮어쓰기 되었을 수 있음
6. 메모리 범위를 넘어선 초기화
    1. malloc으로 할당한 메모리 범위를 넘어서 초기화하면 malloc 동작이 파괴될 수 있음
7. 스택 넘침
    1. 사용자의 입력이 스택프레임을 초과하면 인접한 데이터를 파괴함
    2. 스택, 힙 영역 모두 오버플로우 발생 가능
    3. 스택 프레임을 공격하면 문제가 발생할 수 있음
8. 메모리 누수
    1. 자동 쓰레기 수집을 지원하지 않는 언어에서 흔함
    2. 메모리가 부족한데 계속 요청하면 힙 영역이 늘어나서 프로세스가 강제 종료될 수 있음
    3. 메모리 분석 도구
        1. malloc과 free의 사용 상황 추적
            1. 가끔 프로그램 실행 속도를 저하하고 다시 컴파일해야 할 수 있음
        2. 메모리 누수로 인한 page fault의 호출 스택 정보를 리눅스의 perf 같은 도구로 추적

## 8. SSD를 메모리로 사용할 수 없는 이유

### 메모리 읽기/쓰기와 디스크 읽기/쓰기의 차이

- 메모리 주소 지정 단위는 바이트.
  - 바이트마다 메모리 주소가 부여되고, cpu가 이 주소를 이용하여 해당 내용에 직접 접근
- 하지만 SSD는 아님
  - ssd는 조각 단위로 데이터를 관리하며, 조각의 크기는 매우 다양
  - cpu가 특정 바이트에 직접 접근할 방법이 없음
- 즉 메모린느 바이트 단위, 디스크는 주소 단위로 주소가 지정됨

### 가상 메모리의 제한

- 최신 운영 체제의 메모리 관리는 기본적으로 가상 메모리 기반
  - 32 비트 시스템의 최대 주소 지정 범위는 4GB(2^32)라, 용량이 더 큰 ssd를 사용해도 4gb 이상의 메모리를 사용할 수 없음

### SSD 사용 수명 문제

- ssd는 사용 수명 제한이 있음
  - 수백 tb 수준
  - 따라서 ssd는 읽기 쓰기가 빈번할 수록 좋지 않음