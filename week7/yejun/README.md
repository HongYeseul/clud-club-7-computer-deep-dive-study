## 트랜지스터에서 CPU로, 이보다 더 중요한 것은 없다

### 이 작은 장난감을 CPU라고 부른다

<img width="238" alt="스크린샷 2025-04-13 오후 2 31 59" src="https://github.com/user-attachments/assets/a258050d-7664-4ff6-a71d-c217cbdd3ece" />

트랜지스터는 n-p-n 혹은 p-n-p 반도체로 이루어져 있으며 단자 한쪽에 전류를 흘려 보냈을 때 나머지 단자에 전류가 흐르거나 흐르지 않게하는 `개폐 작업`을 하는 스위치와 비슷

트랜지스터는 다음과 같은 논리 회로를 만들 수 있음

<img width="517" alt="스크린샷 2025-04-13 오후 2 32 57" src="https://github.com/user-attachments/assets/a4fd060f-4ace-45fa-a382-f56b021c0ff4" />

1. 논리곱 게이트(AND gate): 두 개의 스위치가 모두 켜져야 전류가 흐름

2. 논리합 게이트(OR gate): 두 스위치 중 하나라도 켜져있으면 전류가 흐름

3. 논리부정 게이트(NOT gate): 스위치가 켜져있으면 전류가 흐르지 않고, 꺼져있으면 전류가 흐름
___

<img width="670" alt="스크린샷 2025-04-13 오후 2 42 01" src="https://github.com/user-attachments/assets/24cff387-89a9-46d7-adb2-cdb878a45ed3" />

CPU는 수 억개의 트랜지스터를 통해 논리 연산자와, 레지스터를 이룬다.
___

### 하드웨어 아니면 소프트웨어? 범용장치

모든 연산 논리를 반드시 하드웨어로만 구현할 필요는 없으며, 변화할 수 있는 소프트웨어를 통해 변하지 않는 하드웨어에 새로운 기능을 할 수 있도록 유연하게 적용할 수 있다.

변할 수 있는 것은 소프트웨어. `어떤 것을 연산`할 것인가를 소프트웨어가 정하면 된다.

즉, CPU는 `연산 능력`을 제공하고, 프로그래머가 `피연산자`를 제공하면 된다.

이 둘의 인터페이스는 `명령어 집합`이 담당한다.

명령어 집합(instruction set)은 CPU가 실행할 수 있는 명령어(opcode)와 명령어에 필요한 피연산자(operand)를 묶은 것. 서로 다른 종류의 CPU는 서로 다른 명령어 집합을 가진다.

```
예를 들어 다음의 16비트 짜리 기계 명령어가 있다고 하면,
15 14 13 12 | 11 10 09 | 08 07 06 | 05 04 03 | 02 01 00
0  0  0  1  | 1  1  0  |  0  1  0 |  0  0  0 |  1  1  0
    ADD     |    R6    |    R2    |          |    R6
```
처음 4비트가 명령어 집합에 속하는 영역
- 이 예시에서는 명령어 집합이 2^4=16 개의 기계 명령를 포함하고 있을 것이다.

고급 프로그래밍 언어가 컴파일 되면, 이렇게 해당 CPU가 가지는 명령어 집합으로 이루어진 기계 명령어가 되는 것
___

기계 명령어는 회로의 연산 능력, 저장 능력, 그리고 그 회로에 어떤 연산을 수행해야 하는지 알려줄 수 있는 명령어 집합.

각 회로가 함께 작업할 수 있게 조정/동기화 할 수 있는 기능이 있어야 정상적으로 동작 할 수 있다. 이것이 바로 CPU의 `clock signal`

클럭 신호가 전압을 변경할 때 마다 전체 회로의 각 레지스터, 즉 전체 회로 상태가 갱신된다

이렇게 전체 회로를 동기화 한 후에 작업을 실행하기를 반복한다.

클럭 주파수(clock rate)는 이 클럭 신호가 1초에 몇 번 발생하는지를 의미한다.

클럭 주파수가 높을 수록 CPU가 1초에 더 작업을 수행할 수 있는 것이다. (보통 2.6GHz)

___

### CPU는 유휴 상태일 때 무엇을 할까?

<img width="497" alt="스크린샷 2025-04-13 오후 3 20 23" src="https://github.com/user-attachments/assets/056fa249-c3f4-4359-9df4-82b19d6b5a1a" />

실제 컴퓨터의 CPU 사용량은 생각보다 높지 않다.

운영 체제는 여러 프로세스를 스케줄링 하기 위해 각 프로세스에 우선 순위를 매기고 대기열을 통해 관리하는데, 이 대기열이 비어있을 때, 즉 CPU를 사용할 프로세스가 없을 때를 `유휴 상태`라고 한다.

설계의 편의를 위해 이 `유휴 상태를 수행하는` 프로세스가 하나 존재한다. 이를 유휴 작업이라고 하고, 유휴 작업은 언제나 준비상태로, 그리고 가장 낮은 우선순위로 대기열에 항상 존재한다

`스케줄러는 대기열에 스케줄링할 다른 프로세스가 없을 때 이 유휴 프로세스를 스케줄하게 된다`

CPU 유휴 상태 (CPU Idle State):

- 실행할 사용자 또는 시스템 프로세스가 없는 상태
- CPU는 특별한 작업 없이 다음 작업을 기다리는 상태
- CPU는 불필요한 연산을 수행할 필요가 없으므로 전력 소모를 줄일 수 있다

halt 명령: 

- CPU는 실행을 중단하고, 외부 인터럽트 (Interrupt)나 리셋 (Reset) 신호가 발생할 때까지 대기
- CPU는 명령어 파이프라인을 비우고, 내부 클럭 속도를 낮추거나 완전히 멈추는 등의 방식으로 전력 소비를 최소화

위와 같이 halt가 루프 안에서 계속 실행될 때, 어떻게 빠져나올 수 있을까.

컴퓨터에서 일정 시간마다 타이머 인터럽트(timer interrupt)가 발생하는데, 이를 처리하는 과정에서 빠져나올 수 있다. 루프에서 빠져나올 기회를 지속적으로 주는 것

타이머 인터럽트를 CPU가 인식하고, CPU는 운영체제 내부에 등록된 인터럽트 처리 함수를 실행한다. 이 함수는 지금 준비 완료된 프로세스가 있는지 확인해서 있다면 준비 완료된 프로세스를 실행하고, 아니라면 유휴 프로세스를 계속 실행한다.

___



