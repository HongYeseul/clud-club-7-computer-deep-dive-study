## 트랜지스터에서 CPU로, 이보다 더 중요한 것은 없다

### 이 작은 장난감을 CPU라고 부른다

<img width="238" alt="스크린샷 2025-04-13 오후 2 31 59" src="https://github.com/user-attachments/assets/a258050d-7664-4ff6-a71d-c217cbdd3ece" />

트랜지스터는 n-p-n 혹은 p-n-p 반도체로 이루어져 있으며 단자 한쪽에 전류를 흘려 보냈을 때 나머지 단자에 전류가 흐르거나 흐르지 않게하는 `개폐 작업`을 하는 스위치와 비슷

트랜지스터는 다음과 같은 논리 회로를 만들 수 있음

<img width="517" alt="스크린샷 2025-04-13 오후 2 32 57" src="https://github.com/user-attachments/assets/a4fd060f-4ace-45fa-a382-f56b021c0ff4" />

1. 논리곱 게이트(AND gate): 두 개의 스위치가 모두 켜져야 전류가 흐름

2. 논리합 게이트(OR gate): 두 스위치 중 하나라도 켜져있으면 전류가 흐름

3. 논리부정 게이트(NOT gate): 스위치가 켜져있으면 전류가 흐르지 않고, 꺼져있으면 전류가 흐름
___

<img width="670" alt="스크린샷 2025-04-13 오후 2 42 01" src="https://github.com/user-attachments/assets/24cff387-89a9-46d7-adb2-cdb878a45ed3" />

CPU는 수 억개의 트랜지스터를 통해 논리 연산자와, 레지스터를 이룬다.
___

### 하드웨어 아니면 소프트웨어? 범용장치

모든 연산 논리를 반드시 하드웨어로만 구현할 필요는 없으며, 변화할 수 있는 소프트웨어를 통해 변하지 않는 하드웨어에 새로운 기능을 할 수 있도록 유연하게 적용할 수 있다.

변할 수 있는 것은 소프트웨어. `어떤 것을 연산`할 것인가를 소프트웨어가 정하면 된다.

즉, CPU는 `연산 능력`을 제공하고, 프로그래머가 `피연산자`를 제공하면 된다.

이 둘의 인터페이스는 `명령어 집합`이 담당한다.

명령어 집합(instruction set)은 CPU가 실행할 수 있는 명령어(opcode)와 명령어에 필요한 피연산자(operand)를 묶은 것. 서로 다른 종류의 CPU는 서로 다른 명령어 집합을 가진다.

```
예를 들어 다음의 16비트 짜리 기계 명령어가 있다고 하면,
15 14 13 12 | 11 10 09 | 08 07 06 | 05 04 03 | 02 01 00
0  0  0  1  | 1  1  0  |  0  1  0 |  0  0  0 |  1  1  0
    ADD     |    R6    |    R2    |          |    R6
```
처음 4비트가 명령어 집합에 속하는 영역
- 이 예시에서는 명령어 집합이 2^4=16 개의 기계 명령를 포함하고 있을 것이다.

고급 프로그래밍 언어가 컴파일 되면, 이렇게 해당 CPU가 가지는 명령어 집합으로 이루어진 기계 명령어가 되는 것
___

기계 명령어는 회로의 연산 능력, 저장 능력, 그리고 그 회로에 어떤 연산을 수행해야 하는지 알려줄 수 있는 명령어 집합.

각 회로가 함께 작업할 수 있게 조정/동기화 할 수 있는 기능이 있어야 정상적으로 동작 할 수 있다. 이것이 바로 CPU의 `clock signal`

클럭 신호가 전압을 변경할 때 마다 전체 회로의 각 레지스터, 즉 전체 회로 상태가 갱신된다

이렇게 전체 회로를 동기화 한 후에 작업을 실행하기를 반복한다.

클럭 주파수(clock rate)는 이 클럭 신호가 1초에 몇 번 발생하는지를 의미한다.

클럭 주파수가 높을 수록 CPU가 1초에 더 작업을 수행할 수 있는 것이다. (보통 2.6GHz)

___

### CPU는 유휴 상태일 때 무엇을 할까?

<img width="497" alt="스크린샷 2025-04-13 오후 3 20 23" src="https://github.com/user-attachments/assets/056fa249-c3f4-4359-9df4-82b19d6b5a1a" />

실제 컴퓨터의 CPU 사용량은 생각보다 높지 않다.

운영 체제는 여러 프로세스를 스케줄링 하기 위해 각 프로세스에 우선 순위를 매기고 대기열을 통해 관리하는데, 이 대기열이 비어있을 때, 즉 CPU를 사용할 프로세스가 없을 때를 `유휴 상태`라고 한다.

설계의 편의를 위해 이 `유휴 상태를 수행하는` 프로세스가 하나 존재한다. 이를 유휴 작업이라고 하고, 유휴 작업은 언제나 준비상태로, 그리고 가장 낮은 우선순위로 대기열에 항상 존재한다

`스케줄러는 대기열에 스케줄링할 다른 프로세스가 없을 때 이 유휴 프로세스를 스케줄하게 된다`

CPU 유휴 상태 (CPU Idle State):

- 실행할 사용자 또는 시스템 프로세스가 없는 상태
- CPU는 특별한 작업 없이 다음 작업을 기다리는 상태
- CPU는 불필요한 연산을 수행할 필요가 없으므로 전력 소모를 줄일 수 있다

halt 명령: 

- CPU는 실행을 중단하고, 외부 인터럽트 (Interrupt)나 리셋 (Reset) 신호가 발생할 때까지 대기
- CPU는 명령어 파이프라인을 비우고, 내부 클럭 속도를 낮추거나 완전히 멈추는 등의 방식으로 전력 소비를 최소화

위와 같이 halt가 루프 안에서 계속 실행될 때, 어떻게 빠져나올 수 있을까.

컴퓨터에서 일정 시간마다 타이머 인터럽트(timer interrupt)가 발생하는데, 이를 처리하는 과정에서 빠져나올 수 있다. 루프에서 빠져나올 기회를 지속적으로 주는 것

타이머 인터럽트를 CPU가 인식하고, CPU는 운영체제 내부에 등록된 인터럽트 처리 함수를 실행한다. 이 함수는 지금 준비 완료된 프로세스가 있는지 확인해서 있다면 준비 완료된 프로세스를 실행하고, 아니라면 유휴 프로세스를 계속 실행한다.

___

### CPU가 if문을 만났을 때

작업의 처리 과정을 순서가 있는 여러 단계로 나눈 다음,

각 단계에서 다음 단계로 넘어가는 흐름과 지속적인 입력을 통해 전체적인 처리 능력을 높이는 것을 파이프라인이라고 한다.

단, 작업 단위 당 처리시간은 동일하다

CPU 또한 파이프라인을 이용해서 기계 명령어의 처리 능력을 높인다.

하나의 기계 명령어 처리를 위해서 다음의 4단계가 존재한다.

1. 명령어 인출 (instruction fetch: IF)
2. 명령어 해독 (instruction decode: ID)
3. 실행 (execute: EX)
4. 다시 쓰기 (write back: WB)

<img width="545" alt="스크린샷 2025-04-16 오후 8 33 55" src="https://github.com/user-attachments/assets/e6a605c8-ae39-4086-8aa8-c568038c4a04" />

if 문은 일반적으로 컴파일러가 `조건부 점프 명령어`로 변환한다.

조건이 참이면 점프하고, 거짓이라면 순차적으로 실행된다.

그런데 문제는 이 `조건부 점프 명령어`가 `실행` 되어야 점프 여부를 결정할 수 있고, 파이프라인에 어떤 명령어를 넣을지를 결정할 수 있다는 것이다.

만약 조건부 점프 명령어가 실행될 때 까지 파이프라인에 명령어를 넣지 않는다면 프로세서의 리소스를 낭비하는 꼴이 된다.

조건부 점프 명령어의 실행 결과를 알기 전, 파이프라인에 어떤 명령어를 넣어주어야 할지를 결정하기 위해 CPU는 분기 예측 (branch prediction) 을 한다.

이 예측을 통해 분기 결과 도출 전 파이프라인에 예상 명령어를 미리 넣어두고, 예상이 맞았다면 그대로 실행을, 틀렸다면 잘못된 분기 명령어를 모두 무효화 한다. 결국 분기 예측에 실패하면 성능 저하가 발생하는 것.

현대의 CPU 분기 예측은 굉장히 발달되어 있긴 하나, **높은 성능을 요구하는 코드에 if문이 있다면 CPU가 분기 예측에 성공할 확률이 높도록 코드를 작성해야 할 필요가 있다.**

C++의 likely/unlikely 매크로는 이런 이유에서 존재 하며, 컴파일러에 가능성이 더 높은 분기를 알려준다.

CPU의 구현 원리를 이해하는 것으로 CPU를 더 잘 활용하는 코드를 짤 수 있다.

___

### CPU 코어 수와 스레드 수 사이의 관계는 무엇일까?

CPU 코어 수와 스레드 수 사이에는 어떤 필연 관계도 없다.

<img width="514" alt="스크린샷 2025-04-16 오후 8 42 18" src="https://github.com/user-attachments/assets/2c9c8b68-a0a4-4430-9105-023d70d34e88" />

- CPU는 하드웨어로, PC카운터 주소에 따라 메모리에 있는 명령어를 꺼내 실행할 뿐 스레드의 존재를 알지 못하고 알 필요도 없다.
- 스레드는 소프트웨어이고, 정확하게는 `실행 흐름`이자 `작업`, 추상적인 작업의 단위이고, 이를 관리하는 것은 더 큰 소프트웨어인 운영체제이다.
___

- 스레드들의 작업이 입출력/동기화 같은 작업이 필요하지 않은 '순수한 계산' 위주라면

-> 코어당 스레드 하나가 좋은 선택

- 스레드에 블로킹 입출력이 존재한다면

-> 작업을 분할하여 스케줄링 한다는 의미로 다중 스레드를 만들어 사용하는 것이 좋을 것

스레드 수가 한계에 달하면 운영체제 성능이 떨이지기 시작하며 이는 스레드 간 전환의 오버헤드 때문
