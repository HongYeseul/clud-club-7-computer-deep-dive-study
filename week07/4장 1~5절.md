# 4장 CPU


### CPU

- 트랜지스터 : 전류로 동작하는 스위치 같은것. CPU 의 주요 구성
- 논리적 완정성

    ![image](https://github.com/user-attachments/assets/b4d76d26-bf1b-4677-97fc-8c3e0679f04f)

    
    - 논리합, 논리곱, 논리부정
    - 어떤 논리함수도 구현할 수 있음
- 연산은 결과와 자리올림수의 논리연산으로 수행됨
- 값 저장 회로

    ![image](https://github.com/user-attachments/assets/1466b9a5-b159-4d42-be46-7594963f09fe)
    
    → S와 R 중 하나를 0으로 두고 다른 하나를 1로 두면, 회로 출력값인 Q가 각각 항상 1과 0이 되어 값이 저장되었다고 볼 수 있음
    
    ![image](https://github.com/user-attachments/assets/cca1b3c9-1d70-4fc5-bcb5-71eea54df3ea)

    
    → D값에 따라 0또는 1을 저장할 수 있는 회로 = CPU의 1비트 저장단위(사물함)
    
    - 저장회로 여러개 묶음 = 레지스터
    - 메모리 = 저장회로 8비트를 1바이트로 묶고 주소지정
    
    →레지스터와 메모리는 이러한 회로들로 이뤄어져있고, 저장을 위한 전원이 반드시 필요함
    

### 하드웨어와 소프트웨어

- 요리사 = 하드웨어(조합회로) = 변하지 않음
- 레시피 = 소프트웨어(기계명령어) = 변할 수 있음

- 같은 하드웨어에 다른 소프트웨어를 제공하면 새로운 기능을 실행 가능 (기계명령어가 조합회로 위에서 실행됨)

→ 컴퓨터가 범용 연산장치가 됨

- 명령어 집합 = 명령어 + 피연산자
    - CPU 종류에 따라 서로다른 명령어 집합을 가짐
    - SW와 HW가 만나는 인터페이스
- 클럭 신호 : 전체 회로 상태를 갱신하는 신호
- 클럭 주파수 : 1초간 몇번 갱신하는가. 높을수록 1초에 더 많은 작업을 함

- CPU = 산술논리장치(ALU. 연산) + 레지스터(정보 저장) + 클럭신호(타이밍 제어)

### CPU의 유휴상태

- 유휴 프로세스 (Window의 System Idle Process)
    - 항상 준비완료 상태 = 언제든 실행 가능
    - 우선순위 제일 낮음
    - hault 명령을 무한히 실행함
        - CPU를 절전상태로 만드는 일을 함(전력 소비 절약)
        - 커널 상태에서만 실행 가능
- CPU의 프로세스 스케줄링
    - 항상 어떤 프로세스를 큐에서 꺼내 실행하도록 구성
    - 준비 완료 상태의 프로세스가 없으면 유휴 프로세스를 실행 (→ 그래서 우선순위 최하, 항상 준비 완료)
- 타이머 인터럽트 : 일정 시간마다 인터럽트하여 실행 준비완료 프로세스를 확인. 준비안된 프로세스를 실행 중지하고 다른 준비완료된 프로세스를 실행함 → 유휴 프로세스가 무한히 실행되어도 이런 인터럽트 과정을 거쳐 다른 프로세스로 넘어감

### 컴퓨터의 숫자 체계

- 컴퓨터가 2진법을 사용하는 이유 = 트랜지스터 (0,1 만 표현)
- 최상위 비트로 부호 표현
- 숫자 체계
    1. 부호-크기 표현 : 단순히 양수의 맨 앞자리 부호비트만 바꿔 음수 표현 
    2. 1의 보수 : 양수 2진수 전체를 뒤집음
        
        → 사람에게 직관적이지만, 0과 -0 표현이 모두 존재하여 비효율적
        
        → 컴퓨터가 비트연산하기에 불편
        
    3. 2의 보수 : 양수와 덧셈연산을 했을 때 0 (2진수 0000)이 나오는 값을 음수로 사용
        - 특징 : 1의 보수로 표현한 음수 + 1 = 2의보수로 표현한 음수
            
            ![image](https://github.com/user-attachments/assets/f611ef7b-734b-4483-80c2-89911c9e97ed)

        → 컴퓨터의 비트연산 결과가 자연스럽게 정답 값으로 나옴
        
        → 현재 컴퓨터 시스템에서 사용함
        
    - 따라서 2의 보수 표현은 회로 설계를 단순화할 수 있음

- 컴퓨터 연산장치, 즉 CPU는 이런 숫자체계나 스레드에 대해 무지함
    
    그냥 시키는 명령어를 PC레지스터의 주소에서 꺼내와 실행할 뿐임
    

- 프로그래머 = 문제와 논리 → 프로그램
    
    컴파일러 = 프로그램 → 기계명령어
    
    CPU = 기계명령어 실행
    

### CPU의 분기 예측

- 분기 예측 실패율 branch-misses
- 파이프라인 : 작업 단계를 나누어 병렬 처리
    - 기계명령어 처리 4단계 : 명령어 인출 - 명령어 해독 - 실행 - 다시쓰기
    - 각 작업 처리 시간은 동일하나, CPU의 전체 처리량을 늘림
    
    → 앞선 명령어 처리 결과가 나오기 전에 다음 명령어 처리가 시작됨.
    
    다음에 실행할 명령어가 무엇인지 예측해야함
    
- 분기 예측 : 여러 데이터를 바탕으로 CPU가 분기 중 다음에 실행할 명령어를 예측함
    
    예측이 틀리면 성능 손실 발생
    
    → 예측 가능한 코드는 CPU성능에 영향을 줌
    
- pref 등의 분석도구로 분기 예측 실패율 확인, 성능 병목 현상의 원인을 파악하여 개선 가능

### CPU코어 수와 스레드 수

- CPU는 스레드를 모름. OS만 암
- 단일 코어라도, 다중 스레드를 사용하면 동시에 여러 작업을 수행(하는 것처럼)할 수 있다는 의미가 있음
    - e.g. UI를 보여줌과 동시에 뒤에서 필요한 연산을 처리함
    - e.g. 블로킹 입출력 코드를 별도 스레드에서 실행하여 다른 코드를 정상 실행
- 다중 코어일 경우 코어 수 - 스레드 수는 선형관계. 정확한 적정값은 테스트를 통해 찾아가야 함
- 스레드 전환 비용이 있으므로, 특정 스레드 수를 넘어가면 성능이 좋아지지 않음. 많다고 좋은 것x


---
### 더 알아볼 것

- 트랜지스터와 논리회로 구성 실제
    
    https://kbthink.com/main/economy/economic-in-depth-analysis/economic-research-report/series3-230207-1.html
    
- ALU
- sleep() 명령에 대해 - hault와 비교
    - 해당 함수를 호출한 프로세스만 일시중지됨
- likely / unlikely 매크로 : 컴파일러에 가능성이 더 높은 분기를 알려주어 성능 높임
