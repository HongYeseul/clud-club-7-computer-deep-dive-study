# 캐시, 어디에서나 존재하는 것

- CPU의 속도 발전 >> 메모리 속도 발전
- 캐시를 쓰면서 이러한 문제 해결 가능

- 캐시를 써서 속도가 올라가지만 **불일치** 되는 문제 발생 가능

## 캐시 불일치

싱글 스레드에서의 불일치 해결법

1. 캐시 갱신 시 메모리도 같이 갱신 (연속 기입)
2. 캐시 만료 시 메모리에 갱신 (후 기입)

다중 코어 캐시의 일관성

다중 코어 캐시의 일관성은 단순하지 않다.
갱신하려는 변수가 다른 CPU의 캐시에도 있는지 확인하고 있다면 갱신해줘야 한다.
하지만, 당연히도 빈번하게 갱신하는 것은 성능에 악 영향을 준다.

## 가상 메모리

리눅스에서는 남는 메모리를 디스크의 캐시를 활용한다. -> 페이지 캐시

가상 메모리는 물리 메모리의 크기를 초과할 수 있다.
사용하고 있는 메모리 중 일부를 디스크에 기록하고, 해제한 후에 새롭게 할당하는 방식으로
그래서 메모리 사용률이 높은 경우엔 디스크도 자연스럽게 쓰인다.

아 이게 swap 메모리구나

좋은 성능을 내려면 프로그램이 캐시 친화적이어야 한다.

# 캐시 친화적 프로그램

## 지역성

- 시간 지역성
- 공간 지역성

메모리 풀
무작위 동적 할당은 메모리 파편화가 되어있고 공간 지역성이 좋지 못하다.
메모리 풀은 미리 큰 사이즈를 할당받고, 이를 사용한다.
단 이때 연속적인 메모리 공간을 할당받아 공간 지역성을 높인다.

와 struct 선언할 때 변수 연속된거까지 신경쓰는 건 처음 봤는데, 신기하다.

## 핫 데이터 콜드 데이터

- 핫 데이터 : 접근 빈도 높음
- 콜드 데이터 : 접근 빈도 낮음
  빈도가 높은 친구가 히트율이 높도록

배열을 탐색하는 순서에 따라서, 캐시 히트율도 달라진다.

최적화를 할 때는 분석도구를 사용해서 캐시 히트율을 높여서 병목이 되는지 확인한다. 병목이 되지 않는다면 굳이 할 필요는 없다.

# 멀티스레드 성능 방해자

메모리를 캐시에 올릴 때 공간 지역성에 의거해 묶어서(보통 64바이트) 정도로 올린다.

병렬 계산이어도 캐시 일관성을 유지해야하기 때문에, 늘 병렬이 좋은 것은 아니다. 공유 변수를 사용시 캐시 팅김 문제가 발생
-> 스레드 풀을 튜닝할 때 무작정 올리면 안되는 이유?

만약 그렇다면, 각 스레드 끼리 공유 변수가 아예 없거나 읽기 전용 변수만 있다면 스레드를 조금 더 키워도 되지 않을까?
-> 와우, 캐시라인이 동일할 수 있기 때문에, 사실상 캐시 팅김이 발생할 수 있음.
-> 중간에 빈 데이터를 넣어 캐시라인을 분리하는 것 만으로도 효과가 발생.

앞에서 같이 조회되는 친구들을 코드 라인을 바꾸어 메모리에 올렸던 것처럼 반대로 코드 라인을 바꿔 캐시를 쪼개서 올리게할 수도 있음.

# 메모리 장벽

하나의 스레드에서 변수를 바꾸고, 다른 스레드에선 해당 변수를 사용하는 상황

어떤 CPU에서는 순서대로 동작하지 않고, x86에서는 순서대로 동작함.

```c
//스레드 1
x = 1;
a = y;

//스레드 2
y = 1;
b = x;
```

이 때, x86에서는 둘 다 0,0 인 상황이 발생할 수 있다?
어떻게 둘다 0, 0일수가 있지?

## 명령어의 비순차적 실행(OoOE)

명령어는 비순차적으로 실행합니다.

1. 기계어를 생성하는 단계 : 컴파일 중 명령어 재정렬
2. CPU가 명령어를 실행하는 단계 : 명령어가 비순차적으로 실행

어셈블리어를 보면 컴파일 단계시에 재정렬하여 효과를 본다.
하지만 재정렬을 막는것 만으로도 이게 비순차적으로 실행되는걸 완벽하게 막을 순 없다.

CPU는 다음과 같이 연산할거라 생각한다.

1. 명령어 가져오기
2. operand 레지스터에 올리기 이 때, 메모리에서 레지스터에 올라가는 시간이 길어지기에 딜레이
3. 준비되면 명령어 실행
4. 실행 결과 기록

하지만 다음과 같이 한다.

1. 명령어 가져오기
2. 명령어를 대기열에 넣음
3. 레지스터에 올라온 피연산자부터 대기열에서 꺼내 연산 시작
4. 연산 결과를 (기존과 다른) 대기열에 넣기
5. 이전 명령어 실행 결과를 기다렸다가 현재 명령어 실행 결과 기록

## 캐시 일관성...

캐시를 갱신하고 일관성을 유지시키기 위해, L1캐시와 CPU 사이에 저장버퍼를 둔다. (이게 레지스터랑 뭐가 다르지?)
그럼 이거의 일관성 문제는 일어나지 않나?

어쨋거나 이러한 일관성 문제는 공유 변수를 사용하는 경우에 발생한다.

## 네가지 메모리 장벽 유형

1. LoadLoad
2. Store Store
3. Load Store
4. Store Load
    - 가장 무거운 작업 읽기가 완료되어야 load가 되기 때문에 대기시간이 젤 길다.

## 명령어 재정렬은 꼭 필요한가?

솔직히 너무 예측하기 힘든 하위레이어의 문제임. 나는 모르고 싶다.

결론 : 멀티스레드 락 free 프로그래밍을 사용한다면 명령어 재정렬을 걱정하자.

# 궁금점

- 컴파일러는 왜 명령어를 재정렬하면서 최적화를 하는 걸까?
    - 어떻게 탐지하는거지?
- 레지스터는 실제로 어떻게 사용되나?
- 아니 그래서, 어떻게 이 메모리 장벽이 되나? 명시적으로 코드에다가 선언하나?
    - 각 아키텍쳐마다 메모리 장벽이 자동으로 보장되는 경우가 있고 아닌 경우가 있음.
    - 그래서 앞에서 x86의 경우 문제가 안 발생한다고 함 x86은 LoadLoad 보장
    - 아닌 경우엔 실제로 코드로 선언

# 느낀점

캐시의 캐시 캐시의 캐시 계속 중간 계층에 뭐가 생기고 이로 인한 일관성도 계속 생긴다.