# 8주차

## 6. CPU: 복잡 명령어 집합의 탄생

- cpu 입장에서는 프로그램이 컴파일 된 결과만 실행하기에 프로그램에 따른 차이가 없고, 그저 명령어일 뿐임
- 서로 다른 형태의 cpu는 다른 유형의 명령어 집합을 지님
- 명령어 집합의 유형은 코드를 작성하거나 cpu의 하드웨어를 설계하는 데에 영향을 미침
  - x86 구조같은 것들이 이 복잡 명령어 집합에 기초를 두고 있음

### 추상화는 적을수록 좋다

- 컴파일러가 태어난 초기에는 아직 신뢰받지 못하여 많은 프로그램이 어셈블리어로 작성되었음
  - 이 시기에는 더 풍부한 명령어 집합이 강력하다고 여겨짐
  - 근데 메모리 크기는 한정적임(Kb 수준)
  - ⇒ 그래서 더 적은 기계 명령어로 많은 작업을 완료하고, 가변적인 길이의 기계 명령어, 기계 명령어의 밀도를 높여 공간을 절약하는 고도의 인코딩이 필요해짐

[폰 노이만 구조 & 폰 노이만 구조 병목 현상](https://nitro04.blogspot.com/2020/03/bep-1_54.html)

- 더 간단한 명령어인 마이크로코드는 유연성을 높이고, 저장 공간 문제에 도움이 되지만, 버그 가능성이 있으며 트랜지스터를 매우 많이 소모하게 됨

## 7. 축소 명령어 집합의 탄생

- 복잡 명령어 집합은 컴파일러와 저장 장치의 용량 제한같은 제한을 받아 왔음

### 축소 명령어

1. 명령어 자체의 복잡성을 낮춤
    1. 축소 명령 집합은 복잡한 명령어를 제거하고 대신 간단한 명령어 여러 개로 대체함
    2. 명령어 집합을 줄인다는 것은 명령어 집합의 명령어 개수가 줄어든다는 의미가 아니라, 하나의 명령어당 들여야 하는 연산이 더욱 간단해진다는 의미
2. 컴파일러가 cpu에 대해 더 강력한 제어권을 가짐
    1. cpu는 컴파일러에 더 많은 세부사항을 제공함
3. LOAD/STORE 구조
    1. 복잡 명령어 집합에서는 기계 명령어 하나로 메모리에서 데이터를 가져와 작업을 수행하고, 다시 메모리에 쓰는 것이 가능하지만, 축소 명령어 집합에서는 이를 금지함
    2. 축소 명령어 집합의 명령어는 **레지스터 내 데이터만** 처리 가능하며, 메모리 내 데이터는 직접 처리할 수 없음
    3. 데이터를 가져오기 위해 LOAD와 STORE 이라는 전용 기계 명령어만 메모리 읽기 쓰기가 가능

- 복잡 명령어
  - 명령은 쉽지만 그 명령어가 실제 수행하는 작업은 복잡함
  - 고급 언어와 유사
  - 고급 언어와 기계 명령어 간의 차이를 줄임
  - 프로그래머가 최소한의 코드로 작업을 완료함
  - 프로그램 자체가 차지하는 저장공간을 절약함
- 축소 명령어
  - 각 명령어가 최소의 작업을 수행하도록 함
  - 더 많은 저장 공간이 필요
  - 프로그래머를 더 번거롭게 함
    - 근데 사실 설계 의도는 프로그래머가 직접 어셈블리어로 코드를 작성하는게 아니라, 컴파일러가 대신 구체적인 기계 명령어를 자동으로 생성하게 하는 것임

### 명령어 파이프라인

- 파이프라인 기술은 기계 명령어 하나가 실행되는 시간을 단축해 주지는 않음
  - 하지만 처리량을 늘릴 수 있음
  - 따라서 모든 명령어의 실행 시간을 대체적으로 동일하게 하여 파이프라인으로 효율을 높일 수 있음
- 복잡 명령어 집합에서는 명령어 사이의 차이에서 크기와 실행시간이 비례하지 않음
  - 그래서 파이프라인 방식을 제대로 활용하기에는 부적합
- 축소 명령어 집합은 더 많은 명령어를 필요로 하지만 마이크로코드가 없기 때문에 더 적은 트랜지스터를 필요로 함
  - 더 작은 cpu를 만들 수 있음
  - 더 높은 클럭 주파수를 지니기에 더욱 우수함

## 8. 복합 명령어 집합의 반격

- 인터페이스를 이용하면 cpu의 내부 구현, 즉 명령어 실행 방식은 변경이 가능
  - 인터페이스에 해당하는 명령어 집합은 변경 불가
- 복잡 명령어 집합의 명령어를 cpu 내부에서 축소 명령어 집합으로 변경 → 마이크로 명령어
  - 복잡 명령어 집합의 호환성을 유지하면서 축소 명령어 집합의 장점을 지님

### 하이퍼스레딩

- 하드웨어 스레드
- 기존에는 cpu가 한 번에 한 가지 일만 할 수 있다고 간주함
- 하이퍼 스레딩을 사용하면 실제 물리 cpu 코어는 1개이지만 논리적으로 n개의 코어가 있다고 인식함
- 명령어로 파이프라인을 항상 완벽하게 채워서 실행할 수는 없음
  - 빈 공간에 추가 명령어 흐름을 도입하면 전체 파이프라인을 채워서 실행하며 cpu의 리소스를 최대한 활용할 수 있음
- 프로그래머가 인지할 수 있는 소프트웨어 스레드는 생성, 스케줄링, 관리의 주체가 운영체제임
  - 반명 하드웨어 스레드에 해당하는 하이퍼스레딩은 cpu 하드웨어의 기능으로 운영 체제와 상관 없음
- 복잡 명령어 집합과 축소 명령어 집합 구현의 기술적 차이점은 점차 줄어듦

| **구분** | **CISC (Complex Instruction Set Computing)** | **RISC (Reduced Instruction Set Computing)** |
| --- | --- | --- |
| **명령어 특성** | 복잡하고 다양한 명령어, 단일 명령어로 다중 작업 가능 | 단순하고 표준화된 명령어, 실행 시간 균일 |
| **장점** | - **코드 크기 감소**: 복잡한 작업을 간결한 코드로 처리<br>- **메모리 효율성**: 메모리 접근 빈도 낮음<br>- **소프트웨어 단순화**: 하드웨어가 복잡한 연산 처리 | - **단순한 설계**: CPU 설계 간단, 비용 효율적<br>- **고속 실행**: 파이프라이닝과 병렬 처리 용이<br>- **저전력**: 전력 소모 적음(모바일 장치 적합) |
| **단점** | - **복잡한 설계**: 명령어 디코딩 및 실행 복잡<br>- **성능 최적화 어려움**: 파이프라인 최적화 어려움<br>- **전력 소비**: 복잡한 하드웨어로 전력 소모 큼 | - **코드 크기 증가**: 단순 명령어 조합으로 코드 커짐<br>- **소프트웨어 복잡성**: 컴파일러 설계 중요<br>- **메모리 접근 빈도 증가**: 명령어 실행 많아 메모리 대역폭 요구 높음 |

### 상업적 전쟁

- x86은 성능적으로는 열세였지만, 휼륭한 소프트웨어 생태계를 지님
  - 축소 명령어의 장점을 흡수하여 내부적으로는 축소 명ㄹ령어와 유사한 방식으로 실행되도록 함
  - 이로 인해 축소 명령어 집합의 성능을 다시금 넘어서게 됨
- 하지만 스마트폰의 등장에서 윈텔의 늦은 대응으로, ARM은 기회를 갖게 됨
- 애플의 M 시리즈 칩은 축소 명령어 집합의 ARM을 기반으로 성장함

[x86과 arm](https://velog.io/@480/%EC%9D%B4%EC%A0%9C%EB%8A%94-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%8F%84-CPU-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%A5%BC-%EA%B5%AC%EB%B6%84%ED%95%B4%EC%95%BC-%ED%95%A9%EB%8B%88%EB%8B%A4)

## 9. CPU, 스택과 함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리

- cpu에 레지스터가 필요한 것은 속도 때문
  - cpu가 메모리에 접근하는 속도는 레지스터에 비해 매우 느림
- 레지스터와 메모리는 본질적으로 차이가 없으며, 둘 다 정보를 저장하는 데 사용
  - 단지 속도, 경제적 요인에 따라 나누어 사용하는 것임

### 스택 포인터

- 모든 함수는 스택 프레임을 지님
- 중요한 스택 상단 정보는 스택 하단을 가리키는 스택 포인터에 저장됨
- 이 포인터로 함수 호출 스택의 추적이 가능
- 스택 프레임
  - 함수가 실행될 때 함수에 정의된 로컬 변수와 전달된 매개변수 등을 저장하는 독립적인 메모리
  - 함수 호출 단계가 깊어질수록 스택 프레임의 수도 증가
  - 호출 완료 시, 반대 순서로 스택 프레임 수가 줄어듦

### 명령어 주소 레지스터

- 프로그램 카운터라고도 불림
- x86에서는 명령어 포인터라고 불림
- 프로그램이 실행되면 첫 번째로 실행할 기계 명령어의 주소가 pc 레지스터에 저장됨
- cpu는 pc 레지스터에 저장되어 있는 주소에 따라 메모리에서 명령어를 가져와 실행함
- 일반적으로 명령어는 순차적이기에 pc 레지스터 값은 순차적으로 증가
  - 하지만 제어 이전과 관련된 일부 기계 명령어는 새로운 명령어 주소를 pc 레지스터에 저장
  - if문 같은 것들

### 상태 레지스터

- 상태 정보를 저장
- 산술 연산 과정에 발생하는 자리 올림수나 넘침을 저장
- cpu는 기계 명령어를 수행할 때 커널 상태와 사용자 상태를 가짐
- 대부분 프로그래머가 작성한 프로그램은 사용자 상태에서 실행해서 cpu가 특권 명령어를 실행할 수 없음
  - 커널 상태에서 cpu는 특권 명령어를 포함한 어떤 명령어도 실행할 수 있음
- cpu가 어디에서 동작하는 지는 cpu 내부의 상태 레지스터에서 확인 가능
  - 현재 어떤 상태에서 동작 중인지 표시하는 특정한 비트가 있음

### 상황 정보

- 현시점에 레지스터에 저장된 모든 정보를 일반적으로 상황 정보라고 함
- 상황 정보가 필요한 이유는 cpu가 엄격하게 오름차순으로 기계 명령어를 실행하지 않기 때문임
  - 함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리 영향 받음 → 중첩 구조
- cpu는 복구를 대비하여 중단되기 전 상태를 저장해야 함

### 중첩과 스택

- 스택은 중첩 구조를 처리하기 위해 탄생함
- 스택은 구조이기에 구현은 하드웨어, 소프트웨어 어느 것을 통해서도 가능함
- 다시 원래 위치로 점프하기 위해서는 상태 정보에 반환 주소와 사용한 레지스터 정보 등이 필요함
- 모든 함수 실행 시 모두 독점적인 자신만의 저장 공간을 가지고 있으며, 이 저장 공간에 함수 실행 시 상태 정보를 저장할 수 있음
  - 그리고 이 저장 공간을 스택 프레임이라 함

### 시스템 호출과 커널 상태 스택

- 디스크 파일을 읽고 쓰거나 스레드를 생성하는 일은 운영 체제가 함
- 응용 프로그램은 시스템 호출을 통해 운영 체제에 서비스를 요청
- 요청을 완료하는 것은 운영 체제이기에 운영 체제 내부적으로 요청을 처리하기 위한 함수를 호출해야 함
- 그리고 함수 호출 시에는 실행 시간 스택이 필요
- 실행 시간 스택은 커널 상태 스택에 위치
- 모든 사용자 상태 스레드는 커널 상태에 대응하는 커널 상태 스택을 가지고 있음
- 그래서 시스템 호출 시 cpu는 사용자 상태 스레드에 대응하는 커널 상태 스레드를 찾음
- 사용자 상태 스레드의 레지스터 정보 같은 실행 상황 정보는 커널 상태 스택에 저장됨

### 인터럽트와 인터럽트 함수 스택

- 인터럽트는 본질적으로 현재 cpu의 실행 흐름을 끊고 특정 인터럽트 처리 함수로 점프하고 복귀함
- 인터럽트 처리 함수도 함수이기에 실행 시간 스택이 필요
  - 인터럽트 처리 함수에 자체적인 실행 시간 스택이 없는 경우, 인터럽트 처리 함수는 커널 상태 스택을 이용하여 인터럽트 처리를 실행
  - 인터럽트 처리 함수에 인터럽트 처리 함수 스택이 있는 경우, 인터럽트를 처리하는 것은 cpu라서 모든 cpu가 자신만의 인터럽트 처리 함수 스택을 지님
- 시스템 콜과 유사하지만, 시스템 콜은 사용자 상태 프로그램이 직접 실행하고, 인터럽트 처리는 외부 장치로 실행됨

### 스레드 전환과 커널 상태 스택

- 모든 리눅스 스레드에는 각각에 대응하는 프로세스 서술자인 task_struct 구조체가 있으며, 그 안의 thread_struct 구조체가 cpu 상황 정보를 저장하는 역할을 함