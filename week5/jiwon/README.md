# 3. 저수준 계층. 메모리부터

## 1. 메모리의 본질, 포인터와 참조

- cpu는 메모리 없이 동작할 수 없다
- 모든 프로그램은 메모리에서 실행되어야 한다.
- 메모리에는 0과 1만 저장할 수 있다.

### 메모리의 본질

- 메모리는 메모리 쉘로 이루어짐
- 모든 바이트는 메모리 내 자신의 주소를 가짐
- 정보를 조합하여 표시하는 것 → 구조체 또는 객체
    - int의 크기는 cpu 처리 방식과 연관되기에 항상 4바이트라고 고정되는 것이 아님.
- 메모리에 값을 저장하기 위해서는 저장할 숫자 값과 메모리 주소를 명령해야 한다.

### 포인터

- 포인터를 이용하면 불필요한 데이터의 복사본을 만들지 않아도 된다.
- 포인터는 사실 **변수**이고, 이 변수에 저장하기 적합한 값이 메모리 주소일 뿐이다.
- 포인터는 메모리 주소를 더 높은 수준으로 추상화한 것
- 포인터를 지원하지 않는 프로그래밍 언어에서는 내부 로직과는 별도로 메모리 주소를 직접 노출하지 않아 메모리 주소를 확인할 수 없기에 특정 메모리 위치에 있는 데이터를 직접 조작하는 것이 불가능함
- 추상화 수준이 낮을수록 직접 제어할 수 있는 범위가 넓어진다
    - 영향력을 끼칠 수 있는 영역이 넓어진다

### 참조

- 참조를 사용하면 포인터릴 지원하는 대신, 변수의 구체적인 메모리 주소를 얻을 수 없으며 포인터와 유사한 구조의 산술 연산을 할 수 없음
- 메모리 주소 → 포인터 → 참조 순으로 추상화가 더해짐
- 메모리 자체를 추상화 → 가상 메모리

## 2. 메모리 내 프로세스의 모습

- 프로세스 주소 공간에는 코드 영역, 데이터 영역, 힙 영역, 스택 영역이 포함됨
- 코드, 데이터 영역 → 실행 파일을 초기화할 때 생성되는 영역
- 힙 영역 → 동적 메모리 할당에 사용
- 스택 영역 → 함수 호출에 사용
    - 매개변수, 반환 주소, 레지스터 정보 등을 포함한 함수 실행 시 정보를 저장

### 가상메모리

- 코드 영역의 주소가 중복되는 경우가 있음 Ex.0x400000에서 시작
- 메모리의 가짜 주소이기에 메모리 조작 전 실제 물리 메모리 주소로 변경됨
- 프로세스에서는 동일한 크기의 조각으로 나뉘어 물리 메모리에 저장됨 ⇒ 페이지
- 모든 조각은 물리 메모리 전체에 무작위로 흩어져 있음
- 가상 메모리와 물리 메모리 사이의 mapping 관계만 유지하면 됨
    - 페이지 테이블로 매핑 정보를 관리

### 페이지 테이블

- 가상 메모리와 물리 메모리 사이에 **맵핑**이 존재하는 한, 어느 위치에 실제로 저장되는 지 신경 쓰지 않아도 됨
    - 이는 페이지 테이블 덕분

## 3. 스택 영역

### 함수

- 가장 기초적이고 간단한 코드 재사용 방식, 추상화

### 함수 호출 활동 추적 : 스택

- 후입선출 LIFO
- 이진 트리 탐색 → 재귀 구현에 활용
- 프로세스 스택 영역의 높은 주소가 맨 위에 있고 스택 영역은 낮은 주소 방향으로 커진다.
- 스택 영역이 차지하는 메모리는 함수 호출 깊이에 따라 증가하며, 함수 호출이 완료될 때마다 감소함
- 호출로 인하여 함수 제어권이 이전될 때에는 **반환, 점프** 정보가 필요함
    - 반환 : 어디에서 왔는지(출발지)
    - 점프 : 어디로 가는지(목적지)
- 스택 프레임에는 함수를 호출하면 목적지 정보와 출발지 정보가 저장된다.
    - 따라서 함수 호출 이후 되돌아갈 수 있다.

### 매개변수 전달과 반환값의 구현

- cpu는 기계 명령어를 실행할 때 점프와 반환이 가능
- x86-64에서는 대부분의 경우 매개변수의 전달과 반환값을 가져오는 작업을 레지스터로 수행
- cpu 내부의 레지스터 수는 제한되어 있음
    - 전달된 매개변수 수가 사용 가능한 레지스터 수보다 많아지면?
        - 나머지 매개변수는 스택 프레임에 직접 넣을 수 있음
        - 때문에 새로 호출된 함수가 이전 함수의 스택 프레임에서 매개변수를 가져오면 됨
        
        ⇒ **근데 이건 결국 차선책임. 레지스터를 이용하는게 더 빠르고 오버헤드가 없음**
        

### 지역 변수

- 전역 변수는 **실행 파일**의 데이터 영역에 저장되어 있다가 프로그램이 실행되면 **프로세스 주소 공간**의 데이터 영역에 적재됨
- 지역변수는 매개변수와 마찬가지로 레지스터에 저장할 수 있지만, 지역변수가 레지스터 수보다 많으면 스택 프레임에 저장되어야 한다.

### 레지스터의 저장과 복원

- 호출되는 함수가 바뀌면 레지스터에 덮어쓰기 발생 가능
- 그래서 레지스터에 지역 변수를 저장하기 전에 반드시 먼저 레지스터에 원래 있던 초깃값을 꺼냈다가, 레지스터 사용 후 다시 넣어줘야 함
- 원래 있던 값은 스택 프레임에 저장해둠
- 스택 영역의 크기는 한정되어 있음
    - 그래서 너무 큰 지역 변수를 만들면 안됨
    - 함수 호출 단계가 너무 많으면 않됨
- 스택 영역과 힙 영역 사이에는 유휴 영역이 있음
    - 프로그램이 동적 라이브러리에 의존하는 경우, 프로그램이 사용하는 동적 라이브러리가 이 영역에 적재됨
    - 스택 영역이 계속 증가하면 유휴 영역을 점유하게 됨

## 4. 힙 영역: 메모리의 동적 할당

- 함수의 호출 단계가 증가할 때마다 스택 영역이 차지하는 메모리가 늘어남
- 반명 함수 호출이 완료되면 기존 스택 프레임의 정보는 더 이상 사용되지 않으므로 스택 영역이 차지하는 메모리는 그만큼 줄어듦
    - 호출이 종료되면 무효화되깅 이미 사용이 끝난 스택 프레임 정보를 사용하면 안됨
- 지역 변수의 수명 주기는 함수 호출과 동일
    - 이 덕분에 프로그래머는 지역 변수의 메모리 문제를 신경 쓰지 않아도 됨
    - 지역 변수 사용 시점에 해당 변수가 저장된 스택 프레임이 여전히 유효하다면 함수 외부에서 사용 가능함

### 힙 영역이 필요한 이유

- 전역 변수는 모든 모듈에 노출되어 있음
- 여러 함수에서 사용하고 싶지만 노출시키고 싶지 않을 때는
    - 프로그래머가 직접 관리하는 특정 메모리 영역에 저장해야 함
    - 동적 메모리 할당과 해제가 필요
    - 매우 큰 메모리 영역 ⇒ 힙 영역

### malloc 메모리 할당자

- 메모리 할당자 입장에서는 적절한 크기의 메모리 영역을 제공하기만 하면 되지, 그 메모리 영역에 무엇을 저장할지까지는 신경 쓰지 않음
- 메모리 할당자는 요청을 처리할 때 요청된 크기를 만족하는 여유 메모리를 최대한 빨리 찾아야 함
- 사용률을 극대화하고자 정해진 메모리 한도 내에서 최대한 많은 메모리 할당 요청을 만족해야 함
- 메모리 조각의 할당 상태는 조직화를 통해 추적할 수 있음
- 메모리 조각 활용 전략이 필요함

### 여유 메모리 조각 관리

- 연결 리스트
    - 비교적 간단한 구현
    - 어떤 것이 사용 가능하고 어느 것이 사용되었는지 기록하기 편리
    - 메모리 할당자를 구현하기 위해서는 메모리 사용 정보를 메모리 조각 그 자체로 함께 저장해야 함
        - 연견 리스트는 다음 노드가 어디 있는지 알려 주는 포인터가 없지만, 메모리 사용 정보로 다음 노드 위치를 유추할 수 있음
        - 두 가지 정보가 필요함
            1. 해당 메모리 조각이 비어 있는지 알려 주는 설정값(flag)
            2. 해당 메모리 조각의 크기를 기록한 숫자
- 메모리 조각의 최대 크기는 2GB이며, 31비트로 조각 크기를 기록하고 나머지 1비트에는 조각이 비어 있는지, 할당 되어 있는지를 인식하는 데 사용할 수 있음
- 할당 가능한 메모리 조각을 페이로드라고 함
- 머리 주소만 알면 메모리 조각 크기를 더해 다음 노드의 시작 주소를 알 수 있음
- 힙 영역의 모든 메모리를 남김 없이 할당하는 것은 불가능하며, 메모리 조각에 대한 필수 정보를 저장하기 위해 일부는 별도로 사용되어야 함

### 메모리 할당 상태 추적

- 연결 리스트와 마찬가지로 메모리 할당자도 끝을 알려주는 특수한 표시가 필요 → 4바이트 사용됨

### 할당 전략

1. 최초 적합 방식(first fit)
    1. 매번 처음부터 탐색하다가 가장 먼저 요구 사항을 만족하는 항목을 반환
2. 다음 적합 방식
    1. 최초 적합 방식과 유사
    2. 하지만 처음부터 검색하지 않고, 여유 메모리 조각이 마지막으로 발견된 위치에서 탐색 시작함
    3. 이론적으로 최초 적합보다 더 빠르게 여유 메모리 탐색 가능
    4. 다음 적합 방식의 메모리 사용률은 최초 적합 방식에 미치지 못함
3. 최적 적합 방식(best fit)
    1. 사용 가능한 메모리 조각을 모두 찾은 후, 그중 요구 사항을 만족하면서 크기가 가장 작은 조각을 반환함
    2. 다소 느림
    3. 다만 메모리를 더 활용할 수 있음

### 메모리 할당하기

- 여유 메모리를 할당할 때, 여유 공간을 고려하지 않고 있는 그대로 다 제공하면 메모리가 낭비되고 **내부 단편화** 발생 가능 → 해당 내부 메모리 조각 사용 불가
- 여유 메모리 조각을 분환하면 좀 더 활용 가능

### 메모리 해제하기

- 요청한 주소의 메모리를 호출할 때처럼 free(주소)를 하면 됨 → 헤더 정보 바뀜
- 메모리 해제 시, 인접한 메모리 조각이 여유 메모리 조각이면 병합할 수 있음
    - 메모리가 해제될 때 즉시 병합하는 것이 비교적 간단함

### 효율적으로 여유 메모리 조각 병합하기

- 메모리 조각은 이미 머리 정보를 지니고 있음
    - 꼬리 정보를 추가하여 더욱 활용 가능
    - 머리, 꼬리 정보는 메모리 조각을 일종의 암시적 양방향 연결 리스트로 만듦