## 저수준 계층? 메모리라는 사물함에서부터 시작해보자

### 3.2 프로세스는 메모리에서 어떤 모습을 하고 있을까?

프로세스의 주소 공간 구조.

- 코드 영역 - 실행 파일 초기화 시에 명령어가 저장되는 곳
- 데이터 영역 - 실행 파일 초기화 시에 데이터가 저장되는 곳
- 힙 영역 - 동적으로 할당된 메모리를 위한 공간
- 스택 영역 - 함수 호출에 사용되는 공간

실제 물리 메모리는 `조각(chunk)` 단위로 관리 되며, 각 chunk는 프로세스의 주소 공간 속 영역들의 chunk들과 `사상(mapping)` 관계를 지니고 있음.

mapping 관계를 저장하는 곳이 페이지 테이블 (page table).

=> 가상 영역을 물리 메모리로 매핑하여 공간을 이루고 있으며, 해당 공간의 단위를 페이지라고 함

![image](https://github.com/user-attachments/assets/4237305b-405e-4546-92fb-98d082576799)

___

### 3.3 스택 영역: 함수 호출은 어떻게 구현될까?

함수는 가장 기초적이고 간단한 코드 재사용 방식이다.

함수 호출은 `호출 안에 또 다른 호출`이 생길 수 있는데, 이 함수 호출 활동을 추적하기 위해 `후입선출(LIFO)`이 가능한 스택(stack) 이라는 자료구조를 사용.

![image](https://github.com/user-attachments/assets/7d0e32e7-da82-4a85-bfea-95ad69b691a1)

어떤 함수가 실행될 때 사용되는 여러가지 정보를 담아두는 곳을 `스택 프레임(stack frame)` 이라고 함.

이 스택 프레임들이 모여있는 곳이 프로세스의 `스택 영역`이다.
___

어떤 함수를 실행하고 있다는 것은 그 함수가 CPU 제어권을 가지고 있다는 말.

어떤 함수의 실행 중에 다른 함수를 호출하게 되면, CPU 제어권이 이전되어야 함.

CPU 제어권이 이전되고, 원래 실행 중이던 함수로 되돌아 오기 위해서 두 가지 정보가 필요
- 반환(return): 어디에서 왔는지에 대한 정보
  - 다른 함수의 호출 시, 기존에 실행되고 있던 함수에서 호출이 발생한 위치를 저장해둔다. 그래야 다른 함수의 호출이 끝나고 원래 명령어로 복귀할 수 있기 때문.
  - 실행 중이던 함수의 스택 프레임의 가장 끝에 저장해둔다. (스택의 최상단, 메모리 공간에서는 최하단)
- 점프(jump): 어디로 가는지에 대한 정보
  - 또 다른 함수를 호출 할때, 그 함수 명령어가(구체적으로는 명령어의 시작이) 어디에 있는지 대한 정보
  - 호출 시 call 명령어의 인자로, 기존 실행 중이던 함수 명령어에 이미 작성되어있다.

![image](https://github.com/user-attachments/assets/fbb83fe3-cd9d-4006-abda-e74c4e739007)

`매개변수, 반환값, 지역변수` 들은 지정된 `레지스터`에 저장하거나, 레지스터의 개수가 모자라면 `실행 중인 함수의 스택 프레임`에 저장해둔다.

실행 중인 함수가 사용 중이던 레지스터 값들이 다른 함수의 호출로 덮어씌워지지 않도록 

**기존 실행 함수의 레지스터 초기값들은 그 함수의 스택 프레임 최하단 (메모리 공간에서는 최상단)에 저장해 둔다.**

최종적으로 한 함수의 스택프레임은 하단->상단의 순서로 아래와 같이 저장된다.

`레지스터 초기값 | 지역 변수 | 추가 매개변수들 | 반환 주소`
___

### 3.4 힙 영역: 메모리의 동적 할당은 어떻게 구현될까?

만약 특정 데이터를 여러 함수에 거쳐서 사용하고 싶다면? (전역 변수는 모든 모듈에 노출되어 X)

=> 프로그래머에 의해 관리되고 결정되는 메모리 영역 인 힙 영역(heap segment)을 사용

<img width="458" alt="스크린샷 2025-03-31 오후 9 34 47" src="https://github.com/user-attachments/assets/b19ac336-4d76-422f-930f-864cc6446ece" />

___

#### 나만의 메모리 할당자?

메모리 할당자의 성능에 대한 지표.

- 속도: 요청된 크기의 메모리 영역을 얼마나 빨리 힙 영역에서 찾아서 반환해줄 수 있는지
- 활용도: 정해진 힙 영역의 한도 내에서 얼마나 많은 메모리 할당 요청을 만족할 수 있는지

구현을 위해 고려할 사항

- 힙 영역에서 현재 어떤 메모리 조각이 할당 가능한 상태인가?
  - 힙 영역을 `조직화` 해야 어떤 영역이 가용한 상태인지를 추적할 수 있다.
- 할당 가능한 메모리 조각이 여러개라면, 어떤 조각에 할당해야 할까?
- 요청받은 크기의 메모리를 메모리 조각에 할당 후, 그 메모리 조각에 남은 부분은 어떻게 해야할까?
- 사용자로 부터 반환된 메모리를 어떻게 처리해야 할까?

___

#### 1. 메모리 할당 상태 추적

<img width="324" alt="스크린샷 2025-03-31 오후 10 01 47" src="https://github.com/user-attachments/assets/9e3b19ab-fe8e-40b4-97a3-e5b9fe31cd7d" />

연결 리스트로 메모리 사용정보 기록

각 메모리 조각에 헤더(header) 정보를 둔다.

- 메모리 조각의 크기가 얼마인지
- 할당이 된 상태인지

=> 할당 상태와 다음 메모리 조각 헤더 접근도 가능
___

#### 2. 여유 메모리 조각 선택 전략

<img width="490" alt="스크린샷 2025-03-31 오후 9 59 04" src="https://github.com/user-attachments/assets/f1ad5307-6cc2-4df2-b1d2-47716bf2e927" />

1. first-fit: 연결리스트의 앞 부분부터 차례로 할당 할 수 있는 메모리 조각이 있는지 확인
  - 시간이 지날 수록 앞 부분에 작은 조각들이 남게됨. 그래서 탐색 시간이 증가될 수 있음
2. next-fit: 바로 직전에 할당된 조각의 위치부터 시작해 할당 가능한 메모리 조각이 있는지 확인
  - 이론적으로 탐색 시간이 빠르다고 하지만, 메모리 사용률은 first-fit에 미치지 못한 다는 것이 밝혀짐
3. best-fit: 모든 메모리 조각을 확인해서 요청에 적합한 가장 작은 메모리 조각에 할당
  - 탐색 시간이 가장 오래 걸림, 메모리 사용률은 가장 좋음
___

#### 3. 메모리 할당하기

<img width="402" alt="스크린샷 2025-03-31 오후 10 08 01" src="https://github.com/user-attachments/assets/2df49f45-bdaf-4cda-87b5-caf222ce2b14" />

할당 시, 대부분 메모리 조각이 요청 받은 크기보다 크기 때문에 여유 부분이 생김.

잉여 부분을 무시한다면 이는 내부 단편화(fragmentation)가 발생.

=> 여유 메모리를 또다른 메모리 조각으로 만들어서 활용함 (16/1과 16/0으로 메모리 조각을 사용)
___

#### 4. 메모리 해제하기

<img width="450" alt="스크린샷 2025-03-31 오후 10 14 56" src="https://github.com/user-attachments/assets/5ef81b50-8c77-401e-b38c-8464f65ebba9" />

free 요청을 받은 메모리는 헤더 정보를 수정하고, `병합` 해야 함.
병합하지 않으면 작은 메모리 조각을 계속 분리되어 그것보다 큰 메모리 요청에 대응할 수 없음.

단, 병합 시기를 `반환 즉시` 또는 `필요 시(요청에 적합한 메모리 조각이 없을 때)` 둘 중 하나로 선택 가능.

반환 즉시 병합은 구현이 매우 단순하지만, 실제의 메모리 할당자는 대부분 필요 시 병합할 수 있도록 연기 전략을 가지고 있음

또한, 힙 영역을 헤더 정보로만 관리하여 단방향 연결 리스트로 구조화 하면 병합 시 해당 메모리 조각의 앞에 있는 메모리 조각과 병합하기가 어려움

<img width="281" alt="스크린샷 2025-03-31 오후 10 18 06" src="https://github.com/user-attachments/assets/ad62a616-6b6a-48b1-9923-5c48698cf7c1" />

메모리 조각에 footer 를 두고 헤더와 같은 정보를 저장해 둠으로써, 암시적인 양방향 연결 리스트(doubly linked list)로 힙 영역을 관리하도록 함

=> 이전 메모리 조각에 대한 정보에 접근할 수 있어 인접한 여유 메모리 조각을 빠르게 병합할 수 있음
