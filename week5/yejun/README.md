## 저수준 계층? 메모리라는 사물함에서부터 시작해보자

### 3.2 프로세스는 메모리에서 어떤 모습을 하고 있을까?

프로세스의 주소 공간 구조.

- 코드 영역 - 실행 파일 초기화 시에 명령어가 저장되는 곳
- 데이터 영역 - 실행 파일 초기화 시에 데이터가 저장되는 곳
- 힙 영역 - 동적으로 할당된 메모리를 위한 공간
- 스택 영역 - 함수 호출에 사용되는 공간

실제 물리 메모리는 `조각(chunk)` 단위로 관리 되며, 각 chunk는 프로세스의 주소 공간 속 영역들의 chunk들과 `사상(mapping)` 관계를 지니고 있음.

mapping 관계를 저장하는 곳이 페이지 테이블 (page table).

=> 가상 영역을 물리 메모리로 매핑하여 공간을 이루고 있으며, 해당 공간의 단위를 페이지라고 함

![image](https://github.com/user-attachments/assets/4237305b-405e-4546-92fb-98d082576799)

___

### 3.3 스택 영역: 함수 호출은 어떻게 구현될까?

함수는 가장 기초적이고 간단한 코드 재사용 방식이다.

함수 호출은 `호출 안에 또 다른 호출`이 생길 수 있는데, 이 함수 호출 활동을 추적하기 위해 `후입선출(LIFO)`이 가능한 스택(stack) 이라는 자료구조를 사용.

![image](https://github.com/user-attachments/assets/7d0e32e7-da82-4a85-bfea-95ad69b691a1)

어떤 함수가 실행될 때 사용되는 여러가지 정보를 담아두는 곳을 `스택 프레임(stack frame)` 이라고 함.

이 스택 프레임들이 모여있는 곳이 프로세스의 `스택 영역`이다.
___

어떤 함수를 실행하고 있다는 것은 그 함수가 CPU 제어권을 가지고 있다는 말.

어떤 함수의 실행 중에 다른 함수를 호출하게 되면, CPU 제어권이 이전되어야 함.

CPU 제어권이 이전되고, 원래 실행 중이던 함수로 되돌아 오기 위해서 두 가지 정보가 필요
- 반환(return): 어디에서 왔는지에 대한 정보
  - 다른 함수의 호출 시, 기존에 실행되고 있던 함수에서 호출이 발생한 위치를 저장해둔다. 그래야 다른 함수의 호출이 끝나고 원래 명령어로 복귀할 수 있기 때문.
  - 실행 중이던 함수의 스택 프레임의 가장 끝에 저장해둔다. (스택의 최상단, 메모리 공간에서는 최하단)
- 점프(jump): 어디로 가는지에 대한 정보
  - 또 다른 함수를 호출 할때, 그 함수 명령어가(구체적으로는 명령어의 시작이) 어디에 있는지 대한 정보
  - 호출 시 call 명령어의 인자로, 기존 실행 중이던 함수 명령어에 이미 작성되어있다.

![image](https://github.com/user-attachments/assets/fbb83fe3-cd9d-4006-abda-e74c4e739007)

`매개변수, 반환값, 지역변수` 들은 지정된 `레지스터`에 저장하거나, 레지스터의 개수가 모자라면 `실행 중인 함수의 스택 프레임`에 저장해둔다.

실행 중인 함수가 사용 중이던 레지스터 값들이 다른 함수의 호출로 덮어씌워지지 않도록 

**기존 실행 함수의 레지스터 초기값들은 그 함수의 스택 프레임 최하단 (메모리 공간에서는 최상단)에 저장해 둔다.**

최종적으로 한 함수의 스택프레임은 하단->상단의 순서로 아래와 같이 저장된다.

`레지스터 초기값 | 지역 변수 | 추가 매개변수들 | 반환 주소`
___

### 3.4 힙 영역: 메모리의 동적 할당은 어떻게 구현될까?

