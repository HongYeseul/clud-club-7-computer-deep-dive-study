## 1장 - 프로그래밍 언어부터, 프로그램 실행까지 이렇게 진행된다
----

### 1.1 여러분이 프로그래밍 언어를 발명한다면?

CPU는 개폐(on-off)만 이해하는 매우 원시적인 기계이며 이를 숫자로 표현하면 0과 1

인간과 CPU 사이의 언어가 필요 (CPU의 계산이 빠르고 정확했기 때문)
```
# CPU 관점에서의 코드
1101101010011010
1001001100101001
1l00100011011110
1011101101010010
```
___ 
저수준 언어: 천공카드 -> 어셈블리어
기계어를 통해 간단히 기계어로 인간이 읽고, 그에 대응하는 컴퓨터 언어로 변경하는 바이너리 프로그램 개발 (어셈블리어)
```
# 어셈블리어 코드
sub $8, trsp
mov $.1C0, tedi
call puts
mov $0, Beax
```
___
**사람의 추상적인 언어와 CPU가 이해할 수 있는 구체적인 구현으로 변환할 방법이 필요하다**

<p align="center"><img width="500" alt="image"  src="https://github.com/user-attachments/assets/041880bd-6899-42af-a76e-2844635c9c53" /></p>

고급 프로그래밍 언어
1. 명령의 규칙과 패턴을 statement(문): 만약 ..라면 ..하고, 그렇지 않다면 ...한다 (if, else, while, ..)
2. 중첩된 statement를 syntax(구문): if, else, while, func와 같은 반복되는 문을 간결한 문장으로 표현한 것을 구문이라고 함
3. syntax를 컴퓨터가 이해할 수 있도록 syntax tree(구문트리)로 준비: 전체를 보면 어렵지만 하나의 구문들로 쪼개어 보면 이해할 수 있음
4. compiler가 리프노드부터 재귀적으로 기계명령어로 번역: 맨 아래부터 번역해 부모 노드에 적용해 나가다보면 기계 명령어로 전체를 번역할 수 있고 이에 특화된 소프트웨어를 컴파일러라고 함
<p align="center"><img width="500" alt="image" src="https://github.com/user-attachments/assets/e450fffd-1df6-4672-99b3-6eea365d784c" /></p>

___

해석형 언어: CPU 형식 별로 다른 기계어를 쓰는 문제, 마치 영어가 국제 통용어로 사용되듯이 CPU 형식과 무관한 표준 명령어 집합을 정의하고, CPU의 기계 명령어 실행 과정을 모방하는 프로그램을 따로 준비해서 실행할 수 있음

`모방`한다고 표현한 것은, 표준 명령어로만 실행해도 각 CPU의 특성에 맞는 기계명령어가 실행되는 맥락을 의미한 것. 이러한 CPU 시뮬레이션 프로그램을 가상머신(virtual machie) 혹은 인터프리터(interpreter) 라고 부름.
<p align="center"><img width="445" alt="image" src="https://github.com/user-attachments/assets/a6ff6b9c-0b10-41f0-949d-060ce13c02ba" /></p>

---

### 1.2 컴파일러는 어떻게 작동?
___
컴파일러: 고수준 언어를 저수준 언어로 번역하는 `프로그램`의 일종
소스코드를 입력하면 실행 파일을 반환한다. 텍스트 처리 프로그램 이라고 볼 수도 있다.

소스코드에서 토큰(token)을 추출하는 과정을 어휘 분석(lexical analysis)이라고 한다.
```
    int a = 1;
    int b = 2;
    
    while (a < b)
    {
    	b = b - 1;
    }
# Exchange source code to tokens that is to call lexical analysis
    T_Keyword		int
    T_Identifier 	a
    T_Assign		=
    ...
    (각 행이 하나의 토큰을 의미)
```
그 후 코드가 작성된 구문 문법에 따라 토큰을 해석(parsing)한다. 이 과정에서 문법 오류(syntax error)를 검사한다.

만약, while 구문으로 작성된 코드가 있다면 while 키워드의 토큰을 찾으면 다음 토큰은 ( 여야 한다는 전제 하에 해석을 진행, **해석한 구조를 토대로 `구문 트리`를 생성**한다.

이렇게 트리를 생성하는 전체 과정을 구문 분석이라고 한다.

**생성된 구문트리에 이상이 없는지**를 확인하기 위해 의미분석(semantic analysis)을 실행, 이 과정에서 컴파일 오류를 검사
예를 들어, 정수와 문자열을 더할 수 없고 비교 좌우에 있는 자료형이 다르면 안된다.

구문트리를 탐색한 결과로 중간코드(Intermediate Representation Code, IR Code)를 생성
```
# 중간코드
a=1
b=2
goto B
A: b=b-1
B: if a < b goto A
```

컴파일러는 중간 코드를 가지고, 이를 어셈블리어 -> 기계 명령어의 순서로 변환한다.
```
movl $0x1,-0x4(%rbp)  // a=1
movl $0x2,-0x8(%rbp)  // b=2
...
```
소스코드가 소스파일에 있듯 기계 명령어는 대상파일(object file)에 저장되는데(컴파일 완료), 소스파일 당 대상파일이 존재하며 여러 개의 대상파일을 묶어 하나의 실행파일을 만들기 위해 `링크(link)` 라는 작업이 필요

---

### 1.3 링커의 말할 수 없는 비밀
___

링커는 컴파일러가 생성한 대상 파일 여러개를 하나로 묶어 하나의 최종 실행 파일을 생성하는 프로그램의 일종.

여러 개의 대상 파일을 하나로 묶는 행위는 주로 `외부 코드`를 사용해서 프로그래밍 하기 위함.

외부 코드는 `정적 라이브러리` 혹은 `동적 라이브러리(공유 라이브러리)`로 제공될 수 있음.

링크 과정은 심벌 해석(symbol resolution) / 실행 파일 생성 / 재배치(relocation) 등으로 구성.

**심벌 해석(symbol resolution)**

심벌(symbol): 전역 변수와 함수의 이름을 포함하는 모든 변수 이름을 의미.
- 컴파일 된 각 대상파일은 기계 명령어가 저장되는 코드 영역과 전역 변수가 저장되는 데이터 영역으로 나눌 수 있음.
- 컴파일 과정에서는 데이터 영역에서 참조하고 있는 전역 변수들이 실제로 외부에 존재하는지 확인하지 않음.
- 컴파일러는 링커를 위해 각 대상 파일에 심벌들의 수요와 공급을 기록해 두는데 그것이 심벌 테이블(symbol table)이라고 함.
-> 각 대상 파일에서 사용할 외부 심벌에 대해 심벌 테이블에서 유일한 정의를 발견할 수 있는지를 확인하는 작업.

**실행 파일 생성**

정적 라이브러리와 동적 라이브러리는 둘 다 미리 컴파일 되어 있다.
- 정적 라이브러리 (static library) - .lib (win) / .a (linux)
  - 미리 컴파일이 완료된 내용이 실행 파일에 통째로 복제됨 (정적 링크 - static linking)
  - 외부 코드를 함께 매번 컴파일 하지 않아도 되어서 속도 빠름
  - 통째로 복사하기 때문에 메모리와 디스크 낭비
- 동적 라이브러리 (dynamic library): dll (win), lib*.so (linux)
  - 미리 컴파일이 완료된 내용 중, 필수 정보만 실행 파일에 저장됨 (참조된 동적 라이브러리 이름, 심벌 테이블, 재배치 정보 등)
  - 실행 파일을 적재(load)할 때
    - 동적 링커(dynamic linker)라는 별도의 프로세스가 실행 됨.
  - 실행 파일이 실행(runtime)될 때
    - 실행 파일을 생성하는 과정에서 실행 파일 내부에 동적 라이브러리 정보가 저장되지 않음.

**동적 라이브러리의 장/단점**
- 장점
  - 메모리, 디스크 리소스 절약
  - 동적 라이브러리 코드 수정 시, 동적 라이브러리만 다시 컴파일 하면 됨. (실행 파일에는 필수 정보만 저장되어 있기 때문)
  - 플러그인(plug-in)을 구현하는 방법 중 하나. 성능을 위해 프로젝트의 특정 부분을 다른 언어로 개발하고 동적 라이브러리 형태로 사용할 수 있음 (C, C++ 라이브러리를 사용하는 JNI)
- 단점
  - 적재/실행 시간에 링크되기 때문에 성능이 약간 떨어짐
  - 해당 동적 라이브러리를 여러 프로세스가 공유하기 때문에 임의의 메모리 절대 주소로 참조 불가
  - 종속된 동적 라이브러리를 사용할 수 없는 경우 프로그램 실행 불가
 
**재배치(relocation)**

실행 파일을 생성하는 과정

컴파일러가 생성하는 기계 명령어에는 주소값만이 사용되는데, 외부 심벌처럼 컴파일 시점에 주소값을 확정할 수 없는 변수에 대하여 컴파일러는 .relo.text와 .relo.data에 기록해 두고 해당 심벌에 임의의 주소값을 부여.
- 재배치: 각 대상파일을 결합하는 링커가 이 기록을 참고해서 심벌의 메모리 주소를 수정하는 과정.
<p align="center"><img width="450" alt="image" src="https://github.com/user-attachments/assets/b21665b2-b3e1-496b-85f6-30f27f45a870" /></p>
___

### 가상메모리와 링커 설계

<p align="center"><img width="305" alt="image" src="https://github.com/user-attachments/assets/a5ce8e65-a483-4ce6-a036-e5c6e08080f4" /></p>

프로그램이 실행되면 프로세스가 메모리에 적재됨.

힙 영역, 스택 영역, 데이터 영역으로 나뉘는데, 데이터 영역과 스택 영역에 실행 파일의 내용이 메모됨

만약 모든 프로세스가 물리 메모리의 주소를 가지고 실행 파일의 내용을 적어야한다면, 심벌의 메모리 주소가 계속 변동될 것이며, 링커 설계가 매우 까다로워짐

하지만 가상 메모리를 가지고 표준화된 메모리 주소 체계를 가진다면 -> 링커가 메모할 형식이 지정되는것이고, 순차적으로 메모리 주소를 접근하여 작성할 수 있음

실제 물리 메모리 주소는 `페이지 테이블`을 통해 가상 메모리 주소와 매핑되는 정보를 관리하면 됨

<p align="center"><img width="649" alt="image" src="https://github.com/user-attachments/assets/92c92f86-60d0-4b1f-a09d-6ffe0371c9c8" /></p>

---

### 1.4 컴퓨터 과학에서 추상화가 중요한 이유

---
추상화는 표현력을 향상해 의사소통의 효율을 높이고, 세부 사항을 감춰 내용을 보호하게 해줌.

모듈 기반의 설계에서는 API라는 추상화가 존재.
**각 모듈의 내부구조를 알 필요 없이 프로그래밍이 가능하다.**
프로그래밍 언어는 추상화를 지원하기 위한 자신만의 mechanism 을 제공
> 객체지향 언어(object-oriented programming language)의 경우 다형성과 추상 클래스 등을 이용하여 프로그래머가 쉽게 추상화를 이용
> 프로그래머는 내부 구현이 아닌 추상화만 고려하여 프로그래밍이 가능하고, 이는 확장성 향상과 요구사항 변화에 대응하기 좋음

추상화 예시
- CPU - 트랜지스터들로 구성되어 있지만 명령어 집합(instruction set)이라는 개념으로 내부 세부 사항을 보호 -> 트랜지스터 고려 없이 CPU에 작업 지시
- 기계 명령어 - 고급 프로그래밍 언어
- 입출력 장치 - 파일로 추상화 -> 어느 트랙의 어느 섹터에 저장되는지 고려할 필요가 없다.
- 실행중인 프로그램 -> 프로세스 (CPU 스케쥴링을 고려하지 않아도 독립적으로 CPU를 점유하여 활용)
- 물리 메모리와 파일 -> 가상 메모리 (mmap을 고려하지 않아도 메모리에 독점적 접근 가능)
- 네트워크 프로그래밍 -> 소켓 (네트워크 카드가 어떻게 송수신되는지 고려X)
- 프로세스와 프로세스에 종속적인 실행 환경 -> 컨테이너 (배포 환경 고려할 필요가 없어짐)
- CPU, 운영 체제, 응용 프로그램 -> 가상 머신

**자신만의 프로그램, 고급 프로그래머가 되기 위해선 저수준 계층에 대한 이해가 필요하다.**
