## 프로그램이 실행되었지만, 뭐가 뭔지 하나도 모르겠다
___

### 콜백이 필요한 이유

- 특정 이벤트가 발생하고 이를 처리할 수 있는 코드를 호출할 때 콜백함수가 유용
- 콜백함수는 이벤트 핸들러
  - 콜백함수로 전달되는 이벤트 핸들러는 보통 비동기 콜백
  - 동기 콜백이면 이벤트 발행될 때까지 다른 작업 불가 => 동기 방식 처리와 같아 사용할 이유가 없음
___

### 동기와 비동기

![image](https://github.com/user-attachments/assets/60394166-d7b8-4ec7-a438-376cc3848719)

- 동기 호출은 보통 같은 스레드 내에서 진행
- 파일 입출력은 동기지만 다른 스레드에서 진행됨
- read()를 호출하여 파일을 읽는 상황
  - 시스템 콜을 운영체제에 보내고 운영체제는 호출 스레드를 일시 중지 => 커널이 디스크 내용을 읽어오면 호출 스레드가 재시작됨
  - 블로킹 입출력 => 스레드가 여러개여도 동기일 수 있음
 
![image](https://github.com/user-attachments/assets/06737fbf-b055-46fc-b46b-987aa5c31c66)

- 비동기 호출은 시간이 많이 걸리는 입출력 작업을 백그라운드 형태로 실행
  - 파일 읽고 쓰기, 네트워크 데이터 송수신, 데이터베이스 작업 등

- 비동기 호출 방식에서 작업이 실제로 완료되는 시점을 어떻게 파악할 지 두 가지 상황
  - 호출자가 실행결과를 전혀 신경쓰지 않을 때
  - 호출자가 실행결과를 반드시 알아야 할 때
    - 알림 방식
___

### 웹 서버에서의 동기 비동기

![image](https://github.com/user-attachments/assets/c401748a-778b-42fc-8799-ef7bdd7b3866)
1. DB 외 입출력 없는 상황
2. A,B,C 작업
3. 데이터베이스 요청
4. D,E,F 작업

웹서버에는 주 스레드와 데이터베이스 처리 스레드가 존재

- 동기 처리 시 주 스레드의 유휴 시간이 발생
- 비동기 구현에선 주 스레드가 데이터베이스 요청 전송 후 바로 새로운 사용자 요청을 직접 처리함
  - 주스레드가 A,B,C처리 후 데이터베이스 요청 후 새로운 사용자 요청을 받는다면 D,E,F를 어떻게 처리해야하는지

두가지 상황 존재

#### 주 스레드가 데이터베이스 처리 결과를 신경쓰지 않음

![image](https://github.com/user-attachments/assets/567095b0-1348-4834-980c-042937549658)
- 주 스레드가 아닌 데이터베이스 스레드가 데이터베이스 처리 후 이어서 D,E,F처리
- 데이터베이스 스레드가 D,E,F 작업에 대해 알 수 없음
- 주 스레드에서 데이터 베이스 호출과 함께 D,E,F를 콜백함수로 호출한다
___

#### 주 스레드가 데이터베이스 처리 결과에 관심을 가질 때

![image](https://github.com/user-attachments/assets/ab671962-3ab0-4288-aa39-3e5ff46448ee)

- 데이터베이스 스레드는 알림작동 방식을 이용하여 작업 결과를 주 스레드로 전송
- 주스레드는 메시지를 수신하면 D,E,F 처리
- 데이터베이스 스레드가 유휴상태 (입출력 기간동안) 라는점을 제외하면 `주스레드에 유휴시간은 없음`
- 데이터베이스 스레드가 후반부작업을 처리하는 것보다는 비효율적이지만 `동기보다는 효율적`
___

### 블로킹과 논블로킹


#### 입출력 - 일반적으로 입출력 시 호출 스레드가 블로킹 됨

![image](https://github.com/user-attachments/assets/cbc20b5f-85e0-471b-ac66-ef823c530f67)

디스크 예시
- 디스크 입출력 행위는 cpu가 처리하지 않음
- cpu는 입출력 요청을 디스크 컨트롤러에 전달할뿐임
- 실제 디스크 입출력 작업(데이터 읽고 메모리로 전송)은 전용 하드웨어가 처리함
- 디스크가 하나의 트랙 탐색 입출력 요청을 완료하는데 소요되는 시간은 ms단위 수준
- 작업 스레드에서 입출력 과정이 실행되는 동안 cpu 제어권을 다른 스레드에 넘겨 작업 (기존 스레드는 블로킹)할 수 있도록 함
- 완료 후 cpu 제어권을 기존 스레드 혹은 프로세스에서 넘겨받아 다음 작업을 실행함
```
스레드는 I/O 요청을 기다리는 동안 블로킹 상태로 있게 됨
시스템은 다른 스레드가 CPU를 활용할 수 있도록 CPU 제어권을 넘기기 때문에 스레드 차원에서의 블로킹은 맞음
시스템 차원에서 다른 스레드가 CPU를 사용할 수 있도록 한다는 점에서는 논블로킹처럼 보이기도 하지만 개념적으로 스레드가 기다린다는 측면에서 "블로킹"이 맞다
```

#### 논블로킹 입출력 - 호출 후 함수 즉시 반환

![image](https://github.com/user-attachments/assets/33b3e94f-8176-40de-8815-3e99de27dae9)

네트워크 데이터 수신 예시
- 네트워크 수신 함수 recv가 논블로킹이면 이 함수를 호출할 때 운영체제는 호출 스레드를 일시 중지시키는 대신 recv 함수 즉시 반환
- 호출 스레드는 자신의 작업을 계속하며 데이터 수신 작업은 커널이 진행
- 네트워크 데이터 언제 수신했는지 어떻게 알 수 있는 세가지 방법
  - 결과 확인 함수 제공
  - 알림 작동 방식
  - 수신처리 콜백함수를 recv인자로 전달

이런 유형의 입출력 작업이 비동기 입출력
___

### 동기와 블로킹, 비동기와 논블로킹

#### 동기와 블로킹
- 동기 호출이 항상 블로킹인 것은 아님 => 블로킹은 모두 동기 호출임
- funcA함수가 sum함수를 호출했다고 블로킹되거나 스레드가 일시중지 되지는 않음 (동기 함수)
  
#### 비동기와 논블로킹
- recv함수에 비동기 콜백함수 전달한 것은 논블로킹이면서 비동기
- recv함수 호출 후 check함수로 계속해서 결과 감지한다면 논블로킹이지만 동기 (결과를 받은 후 다음 작업이 이루어지므로)

___

### 높은 동시성과 고성을 갖춘 서버 구현

![image](https://github.com/user-attachments/assets/96f19968-f2fa-426b-a48e-bfcc87af8e34)

#### 다중 프로세스
- 간단한 형태의 병행처리방식 일종인 다중 프로세스
- 프로세스간 통신 문제
- 프로세스 생성 종료 성능 부담

![image](https://github.com/user-attachments/assets/04b1b0ba-40fc-4f19-84c6-5369ace77ddf)

#### 다중 스레드
- 프로세스 주소 공간 공유하기 때문에 리소스 공유에 별도 통신 필요 없음
- 스레드 생성 종료 부담 적음
- 각 요청에 대응하는 스레드 생성 가능
- 프로세스 주소공간 공유에 따른 단점 존재 (격리되지 않음)
  - 주소공간 공유하기 때문에 하나의 스레드 강제 종료 시 같은 프로세스 공유하는 모든 스레드와 프로세스 강제 종료됨
- 여러 스레드가 동시에 공유 리소스 읽고 쓸 수 없음

#### 다중 스레드 문제
- 스레드 안전 문제 고려 프로그래밍
- 가볍긴 하나 초당 수십만 건 요청마다 스레드 생성 정도는 성능 이슈 발생
- 메모리 소비
- 스레드 전환 오버헤드

=> 코루틴 활용 가능
___

### 이벤트 순환(이벤트 루프)과 이벤트 구동

이벤트 기반의 동시성을 이용한 이벤트 기반 프로그래밍

![image](https://github.com/user-attachments/assets/4350dd56-e165-4e45-9546-e2dc2e24eca5)

- 이벤트
  - 서버에서 다루는 이벤트는 대부분 입출력
  - 네트워크 데이터 수신 여부, 파일의 읽기 및 쓰기 여부 등
- 이벤트 처리함수
  - 일반적으로 이벤트 핸들러
 
=> 수신 대기하고 수신 시 핸들러를 콜백함수로 던지기만하면 이벤트 처리 
___

### 문제1 - 이벤트 소스와 입출력 다중화

여러 요청은 전부 파일로 취급되어 동시에 여러 사용자 요청이 들어오면 다중 파일 처리를 한 번에 하는 방법이 필요

=> 입출력 다중화 기술로 해결
